<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>å¹ç‰›PPTå¤§å¸ˆ - Demo</title>
  <style>
    :root {
      --game-w: 720px;
      --game-h: 1280px;
      --bg: radial-gradient(1200px 800px at 20% 0%, #0f172a 0%, #0b1324 40%, #0b0c10 100%);
      --panel: #ffffff;
      --brand: #ff4d6d;
      --accent: #5dd39e;
      --text: #1f2937;
      --bg-h: 430px; /* åº•éƒ¨èƒŒæ™¯å›¾é«˜åº¦ï¼ˆå¯æŒ‰éœ€è°ƒæ•´ï¼‰ */
    }
    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', sans-serif;
      color: #111;
      -webkit-tap-highlight-color: transparent;
      overscroll-behavior: none; /* é˜»æ­¢ä¸‹æ‹‰åˆ·æ–°/å›å¼¹ */
    }
    /* ç¦æ­¢é¡µé¢å…ƒç´ è¢«é€‰ä¸­ */
    * {
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    #viewport {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--bg);
      overflow: hidden;
      overscroll-behavior: none;
      touch-action: none; /* é¿å…æµè§ˆå™¨æ‰‹åŠ¿å¹²æ‰° */
    }
    #game {
      width: var(--game-w);
      height: var(--game-h);
      background: linear-gradient(180deg, #f8fafc 0%, #eef2f7 100%);
      border-radius: 18px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.35);
      position: absolute;
      left: 50%;
      top: 50%;
      transform-origin: center center;
    }
    /* é¡¶éƒ¨ HUDï¼šè¿›åº¦æ¡ */
    .hud { position: absolute; top: 0; left: 0; right: 0; height: 120px; display: flex; align-items: center; justify-content: center; }
    .progress { position: relative; width: 680px; height: 28px; background: rgba(255,255,255,0.2); border-radius: 14px; overflow: hidden; box-shadow: inset 0 2px 8px rgba(0,0,0,0.2), 0 4px 12px rgba(0,0,0,0.1); backdrop-filter: blur(8px); border: 1px solid rgba(255,255,255,0.3); }
    .progress .bar { position: absolute; left: 0; top: 0; bottom: 0; width: 100%; background: linear-gradient(90deg, #ff4757 0%, #ff6b7a 25%, #ff8a9b 50%, #ff6b7a 75%, #ff4757 100%); background-size: 200% 100%; animation: pulseBar 2s ease-in-out infinite; transition: width .2s ease-out; }
    @keyframes pulseBar {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }
    .progress .text { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; font-weight: 900; color: #fff; text-shadow: 0 2px 4px rgba(0,0,0,0.8); letter-spacing: 2px; font-size: 16px; }
    .progress.danger .bar { background: linear-gradient(90deg, #ff3838 0%, #ff4757 50%, #ff3838 100%); animation: dangerPulse 0.8s ease-in-out infinite; }
    @keyframes dangerPulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    .bg-wrap { position: absolute; left: 40px; right: 40px; bottom: 36px; height: var(--bg-h); z-index: 1; }
    .bg-img { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: contain; border-radius: 16px; box-shadow: 0 8px 24px rgba(0,0,0,0.18); background:#e5e7eb; }
    .boss-speech { position: absolute; left: 16px; right: 16px; top: 12px; background: #fff; border-radius: 16px; box-shadow: 0 8px 24px rgba(0,0,0,0.15); padding: 20px 24px; min-height: 80px; font-size: 20px; line-height: 1.4; display: flex; align-items: center; border-left: 8px solid var(--brand); z-index: 2; transform: translateY(0) scale(1); opacity: 1; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); }
    .boss-speech.slide-out { transform: translateY(-20px) scale(0.95); opacity: 0; }
    .boss-speech.slide-in { transform: translateY(0) scale(1); opacity: 1; transition-delay: 0.2s; }
    /* PPT ç”»å¸ƒ */
    .slide {
      position: absolute;
      left: 40px; right: 40px; bottom: calc(var(--bg-h) + 64px); top: 120px;
      background: var(--panel);
      border-radius: 16px;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.06), 0 8px 24px rgba(0,0,0,0.12);
      display: grid;
      grid-template-rows: auto 1fr;
      row-gap: 6px;
    }
    .chart-title { padding: 30px 20px 4px 20px; text-align: center; }
    .chart-title .t-main { font-weight: 900; color: var(--text); font-size: 22px; letter-spacing: .5px; }
    .chart-area { position: relative; display: flex; align-items: center; justify-content: center; padding: 0 12px 30px 12px; overflow: hidden; }
    #chart { width: 100%; height: 92%; }
    .page-counter { position: absolute; left: 0; right: 0; bottom: 38px; text-align: center; font-size: 18px; font-weight: 900; color: #111827; }
    .hint { position: absolute; bottom: 8px; left: 12px; right: 12px; text-align: center; font-size: 14px; color: #6b7280; }
    .overlay { position: absolute; inset: 0; display: none; align-items: center; justify-content: center; background: rgba(3,7,18,0.55); color: #fff; flex-direction: column; gap: 24px; border-radius: 18px; z-index: 20; backdrop-filter: blur(6px); }
    .overlay.show { display: flex; }
    .panel { width: 92%; max-width: 680px; background: rgba(255,255,255,0.95); border: 1px solid rgba(255,255,255,0.3); box-shadow: 0 32px 80px rgba(0,0,0,0.4); border-radius: 24px; padding: 48px 40px; text-align: center; transform: scale(0.9); opacity: 0; animation: popIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards; }
    @keyframes popIn {
      to { transform: scale(1); opacity: 1; }
    }
    .panel h1 { margin: 0 0 20px 0; font-size: 48px; font-weight: 900; letter-spacing: -1px; color: #1f2937; line-height: 1.1; }
    .panel p { margin: 16px 0; color: #4b5563; font-size: 24px; line-height: 1.6; font-weight: 500; }
    .panel ul { display: inline-block; text-align: left; margin: 24px auto 32px auto; line-height: 1.8; font-size: 20px; color: #374151; }
    .panel li { margin: 8px 0; }
    .btn { background: linear-gradient(135deg, #ff4d6d, #f87171); color: #fff; border: none; border-radius: 16px; padding: 18px 32px; font-size: 20px; font-weight: 800; cursor: pointer; box-shadow: 0 12px 28px rgba(244,63,94,0.4); transition: all 0.3s ease; transform: translateY(0); }
    .btn:hover { transform: translateY(-2px); box-shadow: 0 16px 36px rgba(244,63,94,0.5); }
    .btn:active { transform: translateY(0); box-shadow: 0 8px 20px rgba(244,63,94,0.3); }
    .btn.secondary { background: #0ea5e9; box-shadow: 0 10px 24px rgba(14,165,233,0.35); }
    .btn.ghost { background: transparent; border: 1px solid rgba(255,255,255,0.5); color: #fff; }
    .legend { font-size: 14px; fill: #4b5563; }
    .label { font-size: 16px; fill: #111827; font-weight: 700; }
    .value { font-size: 14px; fill: #6b7280; }
    .draggable { cursor: grab; touch-action: manipulation; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; pointer-events: auto; }
    .bar-visual { pointer-events: none; }
    .node-visual { pointer-events: none; }
    .pie-handle { pointer-events: none; }
    
    /* è§¦æ‘¸åé¦ˆæ ·å¼ */
    .draggable:active {
      cursor: grabbing;
    }
    
    /* è§¦æ‘¸åŒºåŸŸé«˜äº® */
    .draggable:hover {
      opacity: 0.8;
    }
    
    /* è§¦æ‘¸å¢å¼ºæ ·å¼ */
    .touch-highlight {
      transition: all 0.2s ease;
    }
    
    .touch-highlight:active {
      transform: scale(1.1);
    }

    /* é˜»æ­¢ iOS/å®‰å“ä¸‹æ‹‰åˆ·æ–°ï¼šåœ¨æ ¹èŠ‚ç‚¹æ•è· touchmove å¹¶ç¦æ­¢é»˜è®¤ */
    
    /* å¢å¼ºè§¦æ‘¸å…¼å®¹æ€§ */
    svg * {
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      pointer-events: auto;
    }
    
    .draggable {
      cursor: grab;
      touch-action: manipulation;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      pointer-events: auto;
    }
    
    .draggable:active {
      cursor: grabbing;
    }
    
    .draggable circle,
    .draggable rect {
      pointer-events: auto;
    }
  </style>
</head>
<body>
  <div id="viewport">
    <div id="game">
      <div class="hud">
        <div class="progress"><div class="bar" id="timebar"></div><div class="text" id="timetext">60s</div></div>
      </div>
      <div class="slide">
        <div class="chart-title">
          <div class="t-main" id="title">å…¬å¸æ¦‚å†µ</div>
        </div>
        <div class="chart-area">
          <svg id="chart" viewBox="0 0 660 650" preserveAspectRatio="xMidYMid meet"></svg>
          <div class="hint" id="hint">æ‹–æ‹½å›¾å½¢æ”¹å˜â€œè§†è§‰æ•ˆæœâ€ï¼Œæ•°å€¼ä¸ä¼šå˜</div>
          <div class="page-counter" id="page">å·²å®Œæˆ 0 é¡µ</div>
        </div>
      </div>
      <div class="bg-wrap">
        <img id="img_bg" class="bg-img" alt="bg" src="img_bg.png" />
        <div class="boss-speech" id="boss">â€œè®©å·¦è¾¹é‚£ä¸ªæŸ±å­çœ‹èµ·æ¥æ¯”å³è¾¹é«˜å¾ˆå¤šã€‚â€</div>
      </div>

      <div class="overlay" id="gameover">
        <div class="panel">
          <h1>æ—¶é—´åˆ°ï¼</h1>
          <p id="final">-</p>
          <div style="display:flex;gap:12px;flex-wrap:wrap;justify-content:center;">
            <button class="btn" id="restart">å†æ¥ä¸€å±€</button>
            <button class="btn ghost" id="backHome">è¿”å›æ ‡é¢˜</button>
          </div>
        </div>
      </div>

      <div class="overlay show" id="startscreen">
        <div class="panel">
          <h1>å¹ç‰›PPTå¤§å¸ˆ</h1>
          <p>60 ç§’å†…å°½å¯èƒ½å¤šåœ°å®Œæˆè€æ¿çš„â€œè§†è§‰ä¼˜åŒ–â€ä»»åŠ¡ã€‚</p>
          <ul>
            <li>æŸ±çŠ¶å›¾ï¼šæ‹–æ‹½æŸ±é¡¶æ”¹å˜é«˜åº¦</li>
            <li>æŠ˜çº¿å›¾ï¼šæ‹–æ‹½èŠ‚ç‚¹æ”¹å˜å½¢çŠ¶</li>
            <li>é¥¼å›¾ï¼šæ‹–æ‹½åˆ†å‰²çº¿æ”¹å˜å æ¯”</li>
          </ul>
          <div style="display:flex;gap:12px;flex-wrap:wrap;justify-content:center;">
            <button class="btn" id="startBtn">å¼€å§‹å¹ç‰›</button>
          </div>
          <p id="bestInfo" style="margin-top:12px;font-size:16px;opacity:.9;"></p>
        </div>
      </div>
    </div>
  </div>

  <script>
    // é€‚é…ï¼šå›ºå®š 720x1280ï¼ŒæŒ‰æ¯”ä¾‹ç¼©æ”¾ï¼Œå®Œæ•´æ˜¾ç¤ºï¼ˆcontainï¼Œä¸è£å‰ªï¼‰
    function fit() {
      const game = document.getElementById('game');
      const vw = window.innerWidth, vh = window.innerHeight;
      const scale = Math.min(vw / 720, vh / 1280); // containï¼šå…¨éƒ¨å†…å®¹å¯è§ï¼Œä¸è£å‰ª
      game.style.transform = `translate(-50%, -50%) scale(${scale})`;
    }
    window.addEventListener('resize', fit);
    fit();

    // ç§»åŠ¨ç«¯ï¼šé˜»æ­¢ä¸‹æ‹‰åˆ·æ–°ã€å›å¼¹ï¼Œä½†å…è®¸SVGå†…éƒ¨äº¤äº’
    document.addEventListener('touchmove', (e) => {
      // å¦‚æœæ‰‹åŠ¿å‘ç”Ÿåœ¨æ¸¸æˆå®¹å™¨å†…ï¼Œä½†ä¸åŒ…æ‹¬å¯æ‹–æ‹½å…ƒç´ ï¼Œåˆ™é˜»æ­¢é»˜è®¤æ»šåŠ¨
      const game = document.getElementById('game');
      const target = e.target;
      if (game && game.contains(target) && !target.classList.contains('draggable')) {
        e.preventDefault();
      }
    }, { passive: false });
    
    // ä¿®å¤iOS Safariçš„è§¦æ‘¸é—®é¢˜
    document.addEventListener('touchstart', (e) => {
      // å…è®¸SVGå…ƒç´ æ¥æ”¶è§¦æ‘¸äº‹ä»¶
      const target = e.target;
      if (target.closest('svg')) {
        // å…è®¸äº‹ä»¶ç»§ç»­ä¼ æ’­åˆ°SVGå†…éƒ¨
        return;
      }
    }, { passive: false });

    // å·¥å…·
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const rad = (deg) => deg * Math.PI / 180;
    const deg = (radVal) => radVal * 180 / Math.PI;
    
    // åŠ¨æ•ˆå·¥å…·
    function animateBossSpeech(text) {
      const boss = document.getElementById('boss');
      boss.classList.add('slide-out');
      setTimeout(() => {
        boss.textContent = 'â€œ' + text + 'â€';
        boss.classList.remove('slide-out');
        boss.classList.add('slide-in');
        setTimeout(() => boss.classList.remove('slide-in'), 300);
      }, 300);
    }
    
    // å¢å¼ºå€’è®¡æ—¶è¿›åº¦æ¡åŠ¨æ•ˆ
    function updateProgressBar(timeLeft) {
      const progress = document.querySelector('.progress');
      const bar = document.querySelector('.progress .bar');
      const percentage = (timeLeft / 60) * 100;
      
      // ç§»é™¤æ‰€æœ‰çŠ¶æ€ç±»
      progress.classList.remove('danger');
      
      if (timeLeft <= 10) {
        progress.classList.add('danger');
      }
      
      bar.style.width = `${Math.max(0, percentage)}%`;
    }

    // å…³å¡å®šä¹‰
    const LEVELS = [
      {
        type: 'bar',
        title: 'æ¨¡å‹å¯¹æ¯”',
        boss: 'å…„å¼Ÿä»¬ï¼Œè¿™æ–°æ¨¡å‹ç®€ç›´åŠæ‰“å…¨åœºï¼Œè·Ÿå¼€æŒ‚ä¼¼çš„ï¼',
        hint: '',
        bars: [
          { label: 'CPT-5', value: 40, color: '#ff69b4' },
          { label: 'OpenAL o3', value: 65, color: '#a7f3d0' },
          { label: 'CPT-4o', value: 35, color: '#bfdbfe' },
        ],
        goal: { kind: 'barLargest', index: 0 }
      },
      // æ‰©å±•å…³å¡å¼€å§‹
      { type:'bar', title:'æ´»è·ƒåº¦ç¯æ¯”', boss:'ç¤¾åŒºæ´»è·ƒåº¦ç«å¾—ä¸è¡Œï¼', hint:'', bars:[
        {label:'ä¸€æœˆ', value: 30, color:'#f9a8d4'},
        {label:'äºŒæœˆ', value: 25, color:'#86efac'},
        {label:'ä¸‰æœˆ', value: 35, color:'#93c5fd'},
      ], goal:{ kind:'barIncreasing', index:1 } },

      { type:'line', title:'ç•™å­˜è¶‹åŠ¿', boss:'äº§å“ç²˜æ€§å˜æ€ï¼Œç”¨æˆ·è·Ÿç²˜äº†502ä¼¼çš„ï¼', hint:'', points:[35,33,29,25], labels:['W1','W2','W3','W4'], goal:{ kind:'lineEndAboveStart', margin: 10 } },

      { type:'pie', title:'ç»ˆç«¯åˆ†å¸ƒ', boss:'ç§»åŠ¨ç«¯æ€ç–¯äº†ï¼Œæ•°æ®çˆ†ç‚¸ï¼', hint:'', slices:[
        {label:'ç§»åŠ¨', value: 20, color:'#34d399'},
        {label:'PC', value: 60, color:'#60a5fa'},
        {label:'å¹³æ¿', value: 20, color:'#fde68a'},
      ], goal:{ kind:'pieIndexAtLeast', index:0, fraction: 0.5 } },

      { type:'bar', title:'æ¸ é“è½¬åŒ–', boss:'æ¸ é“è½¬åŒ–ç¦»è°±ï¼Œå¤´éƒ¨ç›´æ¥èµ·é£ï¼', hint:'', bars:[
        {label:'å¹¿å‘Š', value: 25, color:'#f472b6'},
        {label:'è‡ªç„¶', value: 20, color:'#a7f3d0'},
        {label:'å†…å®¹', value: 15, color:'#fca5a5'},
        {label:'è”è¿', value: 30, color:'#c4b5fd'},
      ], goal:{ kind:'barLargest', index:1 } },

      { type:'line', title:'æ€§èƒ½åŸºå‡†(å¸§ç‡)', boss:'å¸§ç‡ç¨³å¾—ä¸€æ‰¹ï¼', hint:'', points:[50,55,52,48], labels:['v1','v2','v3','v4'], goal:{ kind:'lineEndAboveStart', margin: 6 } },

      { type:'pie', title:'åœ°åŒºè¥æ”¶', boss:'æµ·å¤–è¥æ”¶å¼€æŒ‚ï¼Œå…¨çƒéƒ½åœ¨çˆ†ï¼', hint:'', slices:[
        {label:'åŒ—ç¾', value: 25, color:'#93c5fd'},
        {label:'æ¬§æ´²', value: 35, color:'#c4b5fd'},
        {label:'äºšå¤ª', value: 40, color:'#86efac'},
      ], goal:{ kind:'pieLargest', index:2 } },

      { type:'bar', title:'ç ”å‘æŠ•å…¥', boss:'ç ”å‘æŠ•å…¥åœŸè±ªï¼Œä¸šå†…æ¨ªç€èµ°ï¼', hint:'', bars:[
        {label:'21', value: 110, color:'#34d399'},
        {label:'22', value: 100, color:'#60a5fa'},
        {label:'23', value: 95, color:'#fbbf24'},
        {label:'24', value: 80, color:'#f472b6'},
      ], goal:{ kind:'barIncreasing' } },

      { type:'line', title:'å®¢æœå“åº”æ—¶é•¿', boss:'å®¢æœå“åº”å¿«å¾—é£èµ·ï¼Œç”¨æˆ·éƒ½æƒŠäº†ï¼', hint:'', points:[30,28,25,22], labels:['Q1','Q2','Q3','Q4'], goal:{ kind:'lineEndBelowStart', margin: 8 } },

      { type:'pie', title:'åŠŸèƒ½ä½¿ç”¨å æ¯”', boss:'æ ¸å¿ƒåŠŸèƒ½ä½¿ç”¨ç‡é€†å¤©ï¼Œç”¨æˆ·çˆ±ä¸é‡Šæ‰‹ï¼', hint:'', slices:[
        {label:'æ ¸å¿ƒA', value: 15, color:'#34d399'},
        {label:'æ ¸å¿ƒB', value: 20, color:'#60a5fa'},
        {label:'é•¿å°¾', value: 65, color:'#e5e7eb'},
      ], goal:{ kind:'pieIndexAtLeast', index:0, fraction:0.45 } },

      { type:'line', title:'ä¸‹è½½æ—¶é•¿(ç§’)', boss:'ä¸‹è½½å…‰é€Ÿï¼Œç”¨æˆ·éƒ½æƒŠå‘†äº†ï¼', hint:'', points:[20,18,16,12], labels:['v1','v2','v3','v4'], goal:{ kind:'lineEndBelowStart', margin: 6 } },

      { type:'pie', title:'æŠ•è¯‰ç±»å‹å æ¯”', boss:'é—®é¢˜åˆ†ç±»ç²¾å‡†æ‰“å‡»ï¼Œä¼˜åŒ–æ•ˆç‡çˆ†è¡¨ï¼', hint:'', slices:[
        {label:'æ€§èƒ½', value: 35, color:'#fca5a5'},
        {label:'ä½“éªŒ', value: 30, color:'#fbbf24'},
        {label:'å…¶ä»–', value: 35, color:'#e5e7eb'},
      ], goal:{ kind:'pieLargest', index:0 } },

      { type:'bar', title:'æ´»è·ƒåœ°ç†çƒ­åº¦', boss:'åŸå¸‚æ¸—é€ç—…æ¯’å¼ä¼ æ’­ï¼Œç«éå…¨å›½ï¼', hint:'', bars:[
        {label:'ä¸€çº¿', value: 70, color:'#60a5fa'},
        {label:'äºŒçº¿', value: 60, color:'#34d399'},
        {label:'ä¸‰çº¿', value: 40, color:'#fbbf24'},
      ], goal:{ kind:'barIncreasing' } },

      { type:'line', title:'é”™è¯¯ç‡(%)', boss:'ç¨³å®šæ€§å˜æ€ï¼Œé”™è¯¯ç‡éƒ½å¿«å½’é›¶äº†ï¼', hint:'', points:[2.5,2.3,2.2,1.2], labels:['Q1','Q2','Q3','Q4'], goal:{ kind:'lineEndBelowStart', margin: 0.8 } },

      { type:'pie', title:'äººç¾¤å¹´é¾„åˆ†å¸ƒ', boss:'å¹´è½»ç”¨æˆ·èœ‚æ‹¥è€Œè‡³ï¼Œå“ç‰Œé€†é¾„ç”Ÿé•¿ï¼', hint:'', slices:[
        {label:'18-24', value: 22, color:'#93c5fd'},
        {label:'25-34', value: 48, color:'#60a5fa'},
        {label:'35+', value: 30, color:'#c4b5fd'},
      ], goal:{ kind:'pieLargest', index:1 } },

      { type:'bar', title:'å®¢æœæ»¡æ„åº¦', boss:'å®¢æœæ»¡æ„åº¦çˆ†è¡¨ï¼Œäº”æ˜Ÿåˆ·åˆ°æ‰‹è½¯ï¼', hint:'', bars:[
        {label:'å·®è¯„', value: 5, color:'#fca5a5'},
        {label:'ä¸€èˆ¬', value: 15, color:'#fbbf24'},
        {label:'æ»¡æ„', value: 35, color:'#86efac'},
        {label:'å¾ˆæ»¡æ„', value: 45, color:'#34d399'},
      ], goal:{ kind:'barLargest', index:3 } },

      { type:'line', title:'æ´»è·ƒæ—¶æ®µ', boss:'é»„é‡‘æ—¶æ®µæ´»è·ƒå¼€æŒ‚ï¼Œå†…å®¹æ›å…‰ç‚¸å±ï¼', hint:'', points:[20,30,25,35], labels:['ä¸Šåˆ','ä¸‹åˆ','å‚æ™š','å¤œé—´'], goal:{ kind:'lineEndAboveStart', margin: 8 } },

      { type:'pie', title:'è®¢é˜…å¥—é¤å æ¯”', boss:'é«˜é˜¶å¥—é¤å–ç–¯äº†ï¼ŒARPUç›´æ¥èµ·é£ï¼', hint:'', slices:[
        {label:'åŸºç¡€', value: 50, color:'#e5e7eb'},
        {label:'è¿›é˜¶', value: 30, color:'#60a5fa'},
        {label:'æ——èˆ°', value: 20, color:'#34d399'},
      ], goal:{ kind:'pieIndexAtLeast', index:2, fraction:0.35 } },

      { type:'bar', title:'ç«™ç‚¹å¯ç”¨ç‡(%)', boss:'åœ¨çº¿ç‡å˜æ€ï¼Œå…¨å¹´ä¸æ‰çº¿ï¼', hint:'', bars:[
        {label:'Q1', value: 99.0, color:'#86efac'},
        {label:'Q2', value: 99.3, color:'#93c5fd'},
        {label:'Q3', value: 99.6, color:'#fbbf24'},
        {label:'Q4', value: 99.1, color:'#f472b6'},
      ], goal:{ kind:'barIncreasing' } },

      { type:'line', title:'ä»˜è´¹è½¬åŒ–(%)', boss:'è½¬åŒ–ç‡ç«ç®­å‡ç©ºï¼Œå˜ç°æ•ˆç‡çˆ†è¡¨ï¼', hint:'', points:[2.1,2.2,2.0,2.8], labels:['M1','M2','M3','M4'], goal:{ kind:'lineEndAboveStart', margin: 0.5 } },

      { type:'pie', title:'å†…å®¹é¢˜æçƒ­åº¦', boss:'çƒ­ç‚¹è‡ªå¸¦æµé‡ï¼Œä¼˜è´¨å†…å®¹è¢«ç–¯æŠ¢ï¼', hint:'', slices:[
        {label:'ç§‘æŠ€', value: 28, color:'#60a5fa'},
        {label:'ç”Ÿæ´»', value: 40, color:'#34d399'},
        {label:'å¨±ä¹', value: 32, color:'#fbbf24'},
      ], goal:{ kind:'pieLargest', index:1 } },

      { type:'line', title:'å­¦ä¹ æ›²çº¿', boss:'ä¸Šæ‰‹éš¾åº¦å¹¼å„¿å›­çº§åˆ«ï¼Œç”¨æˆ·ç§’å˜è€å¸æœºï¼', hint:'', points:[80,70,60,40], labels:['D1','D2','D3','D4'], goal:{ kind:'lineEndBelowStart', margin: 20 } },

      { type:'bar', title:'çº¿ç´¢åˆ°ç­¾çº¦', boss:'é”€å”®ç®€ç›´å°é’æœºï¼Œè½¬åŒ–ç‡çˆ†è¡¨ï¼', hint:'', bars:[
        {label:'çº¿ç´¢', value: 300, color:'#60a5fa'},
        {label:'å•†æœº', value: 120, color:'#fbbf24'},
        {label:'ç­¾çº¦', value: 40, color:'#34d399'},
      ], goal:{ kind:'barLastMultipleFirst', multiple: 0.5 } },
      {
        type: 'line',
        title: 'æœˆæ´»è¶‹åŠ¿',
        boss: 'æœˆæ´»ä¸€è·¯ç‹‚é£™ä¸å¸¦åœçš„ï¼',
        hint: '',
        points: [120, 100, 80, 75],
        labels: ['Q1','Q2','Q3','Q4'],
        goal: { kind: 'lineEndAboveStart', margin: 40 }
      },
      {
        type: 'pie',
        title: 'å¸‚åœºä»½é¢',
        boss: 'å¸‚åœºè¿™åœ°ä½æ— æ•Œï¼ŒåŠæ‰“å‹å•†åæ¡è¡—ï¼',
        hint: '',
        slices: [
          { label: 'æœ¬å…¬å¸', value: 20, color: '#60a5fa' },
          { label: 'ç«å“A', value: 60, color: '#fca5a5' },
          { label: 'ç«å“B', value: 20, color: '#fde68a' }
        ],
        goal: { kind: 'pieIndexAtLeast', index: 0, fraction: 0.6 }
      },
      {
        type: 'bar',
        title: 'å­£åº¦åˆ©æ¶¦ï¼ˆä¸‡å…ƒï¼‰',
        boss: 'åˆ©æ¶¦çˆ†è¡¨ï¼Œæ•°é’±æ•°åˆ°æ‰‹æŠ½ç­‹ï¼',
        hint: '',
        bars: [
          { label: 'Q1', value: -30, color: '#c4b5fd' },
          { label: 'Q2', value: -35, color: '#93c5fd' },
          { label: 'Q3', value: -25, color: '#86efac' },
          { label: 'Q4', value: -15, color: '#fca5a5' },
        ],
        goal: { kind: 'barIncreasing' }
      },
      {
        type: 'pie',
        title: 'æ»¡æ„åº¦è°ƒæŸ¥',
        boss: 'å£ç¢‘ç‚¸è£‚ï¼Œç”¨æˆ·éƒ½æˆè‡ªæ¥æ°´äº†ï¼',
        hint: '',
        slices: [
          { label: 'å¾ˆæ»¡æ„', value: 15, color: '#34d399' },
          { label: 'æ»¡æ„', value: 30, color: '#6ee7b7' },
          { label: 'å…¶ä»–', value: 55, color: '#e5e7eb' },
        ],
        goal: { kind: 'pieSumAtLeast', indices: [0,1], fraction: 0.9 }
      },
      {
        type: 'pie',
        title: 'è½¬åŒ–æ¥æºå æ¯”',
        boss: 'å¹¿å‘Šæ¸ é“ç®€ç›´æ˜¯é‡‘çŸ¿ï¼Œæµé‡å“—å“—çš„ï¼',
        hint: '',
        slices: [
          { label: 'å¹¿å‘Š', value: 15, color: '#f472b6' },
          { label: 'è‡ªç„¶', value: 65, color: '#93c5fd' },
          { label: 'æ¨è', value: 20, color: '#fde68a' },
        ],
        goal: { kind: 'pieLargest', index: 0 }
      },
    ];

    // å…¨å±€çŠ¶æ€
    let current = 0;
    let score = 0;
    let levelCleared = false; // é˜²æ­¢åŒä¸€å…³å¡å¤šæ¬¡è®¡æ•°
    let timeLeft = 60;
    let timerId = null;
    let isTransitioning = false; // é˜²æ­¢å¿«é€Ÿæ‹–æ‹½å¯¼è‡´é‡å¤è®¡æ•°

    const els = {
      timebar: document.getElementById('timebar'),
      timetext: document.getElementById('timetext'),
      page: document.getElementById('page'),
      boss: document.getElementById('boss'),
      title: document.getElementById('title'),
      subtitle1: document.getElementById('subtitle1'),
      subtitle2: document.getElementById('subtitle2'),
      chart: document.getElementById('chart'),
      hint: document.getElementById('hint'),
      over: document.getElementById('gameover'),
      final: document.getElementById('final'),
      restart: document.getElementById('restart'),
      start: document.getElementById('startscreen'),
      startBtn: document.getElementById('startBtn'),
      backHome: document.getElementById('backHome'),
      bestInfo: document.getElementById('bestInfo'),
    };

    function start() {
      score = 0; current = 0; timeLeft = 60;
      els.page.textContent = `å·²å®Œæˆ ${score} é¡µ`;
      els.timetext.textContent = `${timeLeft}s`;
      updateProgressBar(timeLeft);
      els.over.classList.remove('show');
      els.start.classList.remove('show');
      renderLevel();
      if (timerId) clearInterval(timerId);
      timerId = setInterval(() => {
        timeLeft -= 1;
        els.timetext.textContent = `${timeLeft}s`;
        updateProgressBar(timeLeft);
        if (timeLeft <= 0) {
          clearInterval(timerId);
          timerId = null;
          gameOver();
        }
      }, 1000);
    }

    // æ®µä½ç³»ç»Ÿ
    const TITLES = [
      { min: 0, max: 5, name: 'èŒåœºå°ç™½', icon: 'ğŸŒ±', color: '#9ca3af', desc: 'åˆå…¥èŒåœºï¼Œè¿˜éœ€åŠªåŠ›ï¼' },
      { min: 6, max: 10, name: 'æ•°æ®å­¦å¾’', icon: 'ğŸ“Š', color: '#60a5fa', desc: 'å¼€å§‹æŒæ¡æ•°æ®é­”æ³•ï¼' },
      { min: 11, max: 15, name: 'å›¾è¡¨èƒ½æ‰‹', icon: 'ğŸ“ˆ', color: '#34d399', desc: 'å›¾è¡¨æ“ä½œè¡Œäº‘æµæ°´ï¼' },
      { min: 16, max: 20, name: 'è§†è§‰å¤§å¸ˆ', icon: 'ğŸ¨', color: '#fbbf24', desc: 'è§†è§‰å‘ˆç°å‡ºç¥å…¥åŒ–ï¼' },
      { min: 21, max: 25, name: 'å¹ç‰›ä¸“å®¶', icon: 'ğŸ’¼', color: '#f472b6', desc: 'è€æ¿æœ€çˆ±çš„PPTå¤§å¸ˆï¼' },
      { min: 26, max: 30, name: 'æ•°æ®å½±å¸', icon: 'ğŸ‘‘', color: '#8b5cf6', desc: 'ç™»å³°é€ æï¼Œæ•°æ®ç•Œçš„å¥¥æ–¯å¡ï¼' }
    ];
    
    function getTitle(score) {
      return TITLES.find(t => score >= t.min && score <= t.max) || TITLES[0];
    }
    
    function gameOver() {
      const best = Math.max(score, parseInt(localStorage.getItem('bestScore')||'0',10));
      localStorage.setItem('bestScore', best.toString());
      
      const currentTitle = getTitle(score);
      const bestTitle = getTitle(best);
      
      // æ„å»ºæˆå°±å±•ç¤ºHTML
      const achievementHTML = `
        <div style="text-align: center; margin: 24px 0;">
          <div style="font-size: 64px; margin-bottom: 16px;">${currentTitle.icon}</div>
          <div style="font-size: 28px; font-weight: 900; color: ${currentTitle.color}; margin-bottom: 8px;">
            ${currentTitle.name}
          </div>
          <div style="font-size: 18px; color: #6b7280; margin-bottom: 24px;">
            ${currentTitle.desc}
          </div>
          <div style="display: flex; justify-content: space-around; margin: 32px 0; text-align: center;">
            <div>
              <div style="font-size: 36px; font-weight: 900; color: ${currentTitle.color};">${score}</div>
              <div style="font-size: 16px; color: #6b7280;">æœ¬æ¬¡æˆç»©</div>
            </div>
            <div>
              <div style="font-size: 36px; font-weight: 900; color: ${bestTitle.color};">${best}</div>
              <div style="font-size: 16px; color: #6b7280;">å†å²æœ€ä½³</div>
            </div>
          </div>
          ${score === best && score > 0 ? `
            <div style="background: linear-gradient(135deg, #fbbf24, #f59e0b); color: white; padding: 12px 24px; border-radius: 20px; font-weight: 900; margin: 16px 0; display: inline-block;">
              ğŸ‰ åˆ›é€ æ–°çºªå½•ï¼
            </div>
          ` : ''}
        </div>
      `;
      
      els.final.innerHTML = achievementHTML;
      els.over.classList.add('show');
    }
    els.restart.addEventListener('click', start);
    els.startBtn && els.startBtn.addEventListener('click', start);
    els.backHome && els.backHome.addEventListener('click', () => {
      els.over.classList.remove('show');
      els.start.classList.add('show');
      const best = parseInt(localStorage.getItem('bestScore')||'0',10);
      if (els.bestInfo) els.bestInfo.textContent = best ? `å†å²æœ€ä½³ï¼š${best} é¡µ` : '';
    });

    function nextLevel() {
      if (isTransitioning) return; // é˜²æ­¢é‡å¤è®¡æ•°
      isTransitioning = true;
      
      score += 1;
      els.page.textContent = `å·²å®Œæˆ ${score} é¡µ`;
      current = (current + 1) % LEVELS.length;
      
      // æ·»åŠ å®ŒæˆåŠ¨æ•ˆ
      const svg = els.chart;
      successFlash(svg);
      
      setTimeout(() => {
        renderLevel();
        isTransitioning = false; // é‡ç½®çŠ¶æ€
      }, 400);
    }

    function renderLevel() {
      const lv = LEVELS[current];
      const svg = els.chart;
      svg.innerHTML = '';
      
      // ä½¿ç”¨åŠ¨ç”»æ›´æ–°è€æ¿å¯¹è¯
      animateBossSpeech(lv.boss);
      
      // é‡ç½®çŠ¶æ€
      els.title.textContent = lv.title;
      if (els.subtitle1) {
        els.subtitle1.textContent = lv.sub1 || 'å‰¯æ ‡é¢˜ä¸€ï¼šçœŸå®æ•°æ®ä»…ä½œç¤ºæ„ï¼Œè¯·é€šè¿‡æ‹–æ‹½è°ƒæ•´å›¾å½¢å¤–è§‚ã€‚';
      }
      if (els.subtitle2) {
        els.subtitle2.textContent = lv.sub2 || 'å‰¯æ ‡é¢˜äºŒï¼šå®Œæˆè€æ¿ç›®æ ‡å³å¯è¿›å…¥ä¸‹ä¸€é¡µã€‚';
      }
      // é€šç”¨æ“ä½œæç¤ºï¼šä¾æ®å›¾è¡¨ç±»å‹
      const hints = { bar: 'æç¤ºï¼šå›¾è¡¨å¯äº¤äº’', line: 'æç¤ºï¼šå›¾è¡¨å¯äº¤äº’', pie: 'æç¤ºï¼šå›¾è¡¨å¯äº¤äº’' };
      els.hint.textContent = lv.hint || hints[lv.type] || '';
      
      // ä¸ºæ¯ä¸ªå›¾è¡¨åˆ›å»ºç‹¬ç«‹ä½œç”¨åŸŸï¼Œé¿å…çŠ¶æ€æ±¡æŸ“
      if (lv.type === 'bar') renderBar(lv, svg);
      else if (lv.type === 'line') renderLine(lv, svg);
      else if (lv.type === 'pie') renderPie(lv, svg);
    }

    // ========== æŸ±çŠ¶å›¾ ==========
    function renderBar(lv, svg) {
      const W = 620, H = 560, offsetX = 20, offsetY = 100;
      // åæ ‡ç³»èƒŒæ™¯
      const g = create(svg, 'g', { transform: `translate(20,60)` });
      create(g, 'rect', { x: 0, y: 0, width: W, height: H, fill: '#f8fafc', rx: 12, ry: 12, stroke: '#e5e7eb' });

      const n = lv.bars.length;
      const gap = 24, barW = (W - gap * (n + 1)) / n;
      const baseY = H - 40; // ç•™å‡ºåº•éƒ¨
      const maxVisual = H - 80;

      // ä»¥çœŸå®æ•°å€¼ä¸¥æ ¼æˆæ¯”ä¾‹æ˜¾ç¤ºï¼šæŒ‰ç»å¯¹å€¼ç›¸å¯¹æœ€å¤§å€¼æ˜ å°„
      const values = lv.bars.map(b => b.value);
      const maxAbs = Math.max(1e-6, ...values.map(v => Math.abs(v)));
      const visualHeights = lv.bars.map(b => Math.abs(b.value) / maxAbs * maxVisual);

      // ç”»åˆ»åº¦
      for (let i = 0; i <= 4; i++) {
        const y = 20 + i * ((H-60)/4);
        create(g, 'line', { x1: 0, y1: y, x2: W, y2: y, stroke: '#e5e7eb' });
      }

      // äº¤äº’
      let dragging = null;

      lv.bars.forEach((b, i) => {
        const x = gap + i * (barW + gap);
        const barGroup = create(g, 'g', {});
        // åˆ›å»ºæ›´å¤§çš„è§¦æ‘¸åŒºåŸŸ
        const touchArea = create(barGroup, 'rect', {
          x: x - 10,
          y: 0,
          width: barW + 20,
          height: H,
          fill: 'transparent',
          class: 'draggable'
        });
        const rect = create(barGroup, 'rect', {
          x,
          y: baseY - visualHeights[i],
          width: barW,
          height: visualHeights[i],
          fill: b.color,
          rx: 8,
          class: 'bar-visual'
        });
        const label = create(barGroup, 'text', { x: x + barW/2, y: baseY + 22, 'text-anchor': 'middle', class: 'legend' });
        label.textContent = b.label;
        const value = create(barGroup, 'text', { x: x + barW/2, y: baseY + 40, 'text-anchor': 'middle', class: 'value' });
        value.textContent = `${b.value}`;

        const startHandler = (e) => { 
          e.preventDefault();
          e.stopPropagation();
          dragging = i; 
          if (e.pointerId !== undefined) touchArea.setPointerCapture(e.pointerId);
          rect.style.transform = 'scale(1.05)';
          rect.style.transformOrigin = 'center bottom';
          rect.style.transition = 'transform 0.1s';
        };
        const endHandler = (e) => { 
          e.preventDefault();
          e.stopPropagation();
          dragging = null; 
          rect.style.transform = 'scale(1)';
          // æ‹–æ‹½ç»“æŸæ—¶æ£€æŸ¥é€šå…³æ¡ä»¶ï¼Œå»¶è¿Ÿæ‰§è¡Œé¿å…çŠ¶æ€å†²çª
          setTimeout(() => {
            if (!isTransitioning && checkBarGoal(lv.goal, visualHeights)) {
              nextLevel();
            }
          }, 50);
        };
        const moveHandler = (e) => {
          if (dragging !== i) return;
          e.preventDefault();
          e.stopPropagation();
          const pt = localPoint(svg, e);
          const localY = pt.y - 60; // å‡å» translate
          const h = clamp(baseY - localY, 20, maxVisual);
          visualHeights[i] = h;
          rect.setAttribute('y', baseY - h);
          rect.setAttribute('height', h);
          checkBarGoal(lv.goal, visualHeights);
        };
        
        // æ”¯æŒé¼ æ ‡äº‹ä»¶
        touchArea.addEventListener('mousedown', startHandler);
        touchArea.addEventListener('mouseup', endHandler);
        touchArea.addEventListener('mouseleave', endHandler);
        touchArea.addEventListener('mousemove', moveHandler);
        
        // æ”¯æŒæŒ‡é’ˆäº‹ä»¶
        touchArea.addEventListener('pointerdown', startHandler);
        touchArea.addEventListener('pointerup', endHandler);
        touchArea.addEventListener('pointercancel', endHandler);
        touchArea.addEventListener('pointermove', moveHandler);
        
        // æ”¯æŒè§¦æ‘¸äº‹ä»¶
        touchArea.addEventListener('touchstart', startHandler, { passive: false });
        touchArea.addEventListener('touchend', endHandler);
        touchArea.addEventListener('touchcancel', endHandler);
        touchArea.addEventListener('touchmove', moveHandler, { passive: false });
      });
    }

    function checkBarGoal(goal, heights) {
      if (!goal) return false;
      const minGap = 10;
      switch(goal.kind) {
        case 'barLargest': {
          const idx = goal.index;
          return heights.every((h, i) => i === idx || heights[idx] >= h + minGap);
        }
        case 'barIncreasing': {
          for (let i = 0; i < heights.length - 1; i++) {
            if (!(heights[i] + minGap < heights[i+1])) return false;
          }
          return true;
        }
        case 'barLastMultipleFirst': {
          const m = goal.multiple || 2;
          return heights[heights.length - 1] >= heights[0] * m;
        }
      }
      return false;
    }

    // ========== æŠ˜çº¿å›¾ ==========
    function renderLine(lv, svg) {
      const W = 620, H = 560, L = 50, T = 60;
      const g = create(svg, 'g', { transform: `translate(20,60)` });
      create(g, 'rect', { x: 0, y: 0, width: W, height: H, fill: '#f8fafc', rx: 12, ry: 12, stroke: '#e5e7eb' });

      const n = lv.points.length;
      const X0 = L, Y0 = H - 40, chartW = W - L - 20, chartH = H - T - 40;
      const stepX = chartW / (n - 1);
      // åˆå§‹è§†è§‰ç‚¹ä½ï¼šä¸¥æ ¼æŒ‰çœŸå®å€¼æ˜ å°„
      const maxVal = Math.max(...lv.points);
      const minVal = Math.min(...lv.points);
      const mapY = v => Y0 - (v - minVal) / Math.max(1, (maxVal - minVal)) * chartH;
      const vPoints = lv.points.map((v,i) => ({ x: X0 + i*stepX, y: mapY(v) }));

      // ç½‘æ ¼
      for (let i=0;i<=4;i++) {
        const y = T + i * (chartH/4);
        create(g, 'line', { x1: X0, y1: y, x2: X0 + chartW, y2: y, stroke: '#e5e7eb' });
      }
      create(g, 'line', { x1: X0, y1: T, x2: X0, y2: Y0, stroke: '#d1d5db' });
      create(g, 'line', { x1: X0, y1: Y0, x2: X0 + chartW, y2: Y0, stroke: '#d1d5db' });

      const path = create(g, 'polyline', { fill: 'none', stroke: '#2563eb', 'stroke-width': 3, points: pointsStr(vPoints) });

      // çœŸå®æ•°æ®æ ‡ç­¾
      vPoints.forEach((p, i) => {
        const tx = create(g, 'text', { x: p.x, y: Y0 + 22, 'text-anchor': 'middle', class: 'legend' });
        tx.textContent = lv.labels ? lv.labels[i] : `P${i+1}`;
        const val = create(g, 'text', { x: p.x, y: Y0 + 40, 'text-anchor': 'middle', class: 'value' });
        val.textContent = lv.points[i];
      });

      let dragging = -1;
      vPoints.forEach((p, i) => {
        // åˆ›å»ºæ›´å¤§çš„è§¦æ‘¸åŒºåŸŸï¼ˆé€æ˜å¤§åœ†ï¼‰
        const touchArea = create(g, 'circle', { 
          cx: p.x, 
          cy: p.y, 
          r: 25, // è§¦æ‘¸åŒºåŸŸåŠå¾„
          fill: 'transparent', 
          class: 'draggable' 
        });
        // åˆ›å»ºå¯è§å°åœ†
        const c = create(g, 'circle', { 
          cx: p.x, 
          cy: p.y, 
          r: 8, 
          fill: '#2563eb', 
          stroke: '#fff', 
          'stroke-width': 2,
          class: 'node-visual' 
        });
        
        const startHandler = (e) => { 
          e.preventDefault();
          e.stopPropagation();
          dragging = i; 
          if (e.pointerId !== undefined) touchArea.setPointerCapture(e.pointerId);
          c.setAttribute('r', 12); // è§¦æ‘¸åé¦ˆ
          c.setAttribute('stroke-width', 3);
        };
        const endHandler = (e) => { 
          e.preventDefault();
          e.stopPropagation();
          dragging = -1; 
          c.setAttribute('r', 8);
          c.setAttribute('stroke-width', 2);
          // æ‹–æ‹½ç»“æŸæ—¶æ£€æŸ¥é€šå…³æ¡ä»¶ï¼Œå»¶è¿Ÿæ‰§è¡Œé¿å…çŠ¶æ€å†²çª
          setTimeout(() => {
            if (!isTransitioning && checkLineGoal(lv.goal, vPoints)) {
              nextLevel();
            }
          }, 50);
        };
        const moveHandler = (e) => {
          if (dragging !== i) return;
          e.preventDefault();
          e.stopPropagation();
          const pt = localPoint(svg, e);
          const local = { x: clamp(pt.x - 20, X0, X0 + chartW), y: clamp(pt.y - 60, T, Y0) };
          p.y = local.y;
          // åŒæ—¶æ›´æ–°è§¦æ‘¸åŒºåŸŸå’Œå¯è§åœ†çš„ä½ç½®
          c.setAttribute('cy', p.y);
          touchArea.setAttribute('cy', p.y);
          path.setAttribute('points', pointsStr(vPoints));
          checkLineGoal(lv.goal, vPoints);
        };
        
        // æ”¯æŒé¼ æ ‡äº‹ä»¶
        touchArea.addEventListener('mousedown', startHandler);
        touchArea.addEventListener('mouseup', endHandler);
        touchArea.addEventListener('mouseleave', endHandler);
        touchArea.addEventListener('mousemove', moveHandler);
        
        // æ”¯æŒæŒ‡é’ˆäº‹ä»¶
        touchArea.addEventListener('pointerdown', startHandler);
        touchArea.addEventListener('pointerup', endHandler);
        touchArea.addEventListener('pointercancel', endHandler);
        touchArea.addEventListener('pointermove', moveHandler);
        
        // æ”¯æŒè§¦æ‘¸äº‹ä»¶
        touchArea.addEventListener('touchstart', startHandler, { passive: false });
        touchArea.addEventListener('touchend', endHandler);
        touchArea.addEventListener('touchcancel', endHandler);
        touchArea.addEventListener('touchmove', moveHandler, { passive: false });
      });
    }

    function pointsStr(arr) { return arr.map(p => `${p.x},${p.y}`).join(' '); }
    function checkLineGoal(goal, pts) {
      if (!goal) return false;
      const startY = pts[0].y, endY = pts[pts.length - 1].y;
      switch(goal.kind) {
        case 'lineEndAboveStart': {
          return startY - endY > (goal.margin || 20);
        }
        case 'lineEndBelowStart': {
          return endY - startY > (goal.margin || 20);
        }
        case 'lineEndBelowRatio': {
          // è¿™é‡Œç”¨ Y è½´æœä¸‹ï¼šè¶Šå¤§è¶Šä½ã€‚ç›®æ ‡ï¼šend <= start * ratioï¼ˆè§†è§‰æ˜¾è‘—é™ä½ï¼‰
          // æ¢æˆåƒç´ å·®åˆ¤å®šï¼šstart - end >= (1-ratio) * 200 åƒç´ 
          const need = 160 * (1 - (goal.ratio || 0.5));
          return startY - endY >= need;
        }
      }
      return false;
    }

    // ========== é¥¼å›¾ ==========
    function renderPie(lv, svg) {
      const g = create(svg, 'g', { transform: `translate(330,380)` });
      const R = 180;
      const slices = lv.slices;
      // è¾¹ç•Œè§’æ•°ç»„ï¼ˆç»å¯¹è§’åº¦ï¼Œ0..2Ï€ï¼‰ï¼Œé•¿åº¦ä¸ºåˆ‡ç‰‡æ•°é‡ nï¼›ç¬¬ i æ®µä¸º [bounds[i], bounds[i+1])ï¼Œæœ€åä¸€æ®µé—­åˆåˆ° bounds[0]+2Ï€
      const sum = slices.reduce((s,it)=>s+it.value,0);
      let bounds = [0];
      let acc = 0;
      for (let i=0;i<slices.length-1;i++) { acc += (slices[i].value / sum) * Math.PI*2; bounds.push(acc); }
      // DOMï¼šå›ºå®šèŠ‚ç‚¹ï¼Œæ‹–åŠ¨æ—¶ä»…æ›´æ–°å±æ€§
      create(g, 'circle', { cx:0, cy:0, r:R+20, fill:'#f8fafc', stroke:'#e5e7eb' });
      const paths = slices.map(()=> create(g,'path', { stroke:'#fff', 'stroke-width':2 }));
      const labels = slices.map(()=> create(g,'text', { class:'label' }));
      // åˆ›å»ºæ›´å¤§çš„è§¦æ‘¸åŒºåŸŸï¼ˆé€æ˜å¤§åœ†ï¼‰
      const touchAreas = bounds.map(()=> create(g,'circle', { r:30, fill:'transparent', class:'draggable' }));
      // åˆ›å»ºå¯è§æ§åˆ¶ç‚¹
      const handles = bounds.map(()=> create(g,'circle', { r:12, fill:'#111827', stroke:'#fff', 'stroke-width':2, opacity:0.5, class:'pie-handle' }));

      const TWO = Math.PI*2;
      const norm = (a)=>{ const t=a%TWO; return t<0?t+TWO:t; };
      const fwd = (a,b)=> (b - a + TWO) % TWO; // ä»aæ²¿æ­£å‘åˆ°bçš„è§’è·ç¦»
      const arcD = (a0,a1)=>{
        const end = a0 + fwd(a0, a1);
        const large = (end-a0)>Math.PI?1:0;
        const p0={x:Math.cos(a0)*R,y:Math.sin(a0)*R};
        const p1={x:Math.cos(end)*R,y:Math.sin(end)*R};
        return `M0,0 L${p0.x},${p0.y} A ${R} ${R} 0 ${large} 1 ${p1.x},${p1.y} Z`;
      };

      function boundsToAngles(bnds){
        // ç”Ÿæˆ [0, ..., 2Ï€] å½¢å¼ï¼Œä¾›ç›®æ ‡åˆ¤å®šä½¿ç”¨
        const base=bnds[0];
        const arr=[0];
        for(let i=1;i<bnds.length;i++) arr.push(norm(bnds[i]-base));
        arr.push(TWO);
        return arr;
      }

      function update(){
        // æ›´æ–°æ‰‡å½¢ä¸æ–‡å­—
        for(let i=0;i<slices.length;i++){
          const a0=bounds[i];
          const a1=(i===slices.length-1) ? bounds[0] : bounds[i+1];
          paths[i].setAttribute('d', arcD(a0,a1));
          paths[i].setAttribute('fill', slices[i].color);
          const mid = a0 + fwd(a0, a1) / 2; // ä½¿ç”¨æ­£å‘è·¨åº¦ï¼Œé¿å…è·¨åœˆå¯¼è‡´çš„æ ‡ç­¾è·³åŠ¨
          const px=Math.cos(mid)* (R+36); const py=Math.sin(mid)*(R+36);
          labels[i].setAttribute('x', px); labels[i].setAttribute('y', py);
          labels[i].setAttribute('text-anchor', px>=0?'start':'end');
          labels[i].textContent=`${slices[i].label} ${slices[i].value}%`;
        }
        // æŠŠæ‰‹ï¼ˆå«ç¼åˆå¤„ index=0ï¼‰
        for(let k=0;k<handles.length;k++){
          const a=bounds[k];
          const x = Math.cos(a)*R;
          const y = Math.sin(a)*R;
          handles[k].setAttribute('cx', x);
          handles[k].setAttribute('cy', y);
          touchAreas[k].setAttribute('cx', x);
          touchAreas[k].setAttribute('cy', y);
        }
      }

      function clampAround(index, aNew){
        const margin=0.1;
        const prevIndex=(index-1+slices.length)%slices.length;
        const nextIndex=(index+1)%slices.length;
        const start = norm(bounds[prevIndex] + margin);
        const end = norm(bounds[nextIndex] - margin);
        // å°† aNew é™åˆ¶åœ¨ä» start åˆ° end çš„æ­£å‘å¼§æ®µå†…
        const segLen = fwd(start, end);
        let d = fwd(start, norm(aNew));
        if (d > segLen) d = segLen;
        const a = norm(start + d);
        bounds[index]=a;
      }

      let active=-1;
      touchAreas.forEach((touchArea, idx)=>{
        const startHandler = (e) => { 
          e.preventDefault();
          e.stopPropagation();
          active = idx; 
          if (e.pointerId !== undefined) touchArea.setPointerCapture(e.pointerId);
          handles[idx].setAttribute('r', 18); // è§¦æ‘¸åé¦ˆ
          handles[idx].setAttribute('opacity', 0.8);
          handles[idx].setAttribute('stroke-width', 3);
        };
        const endHandler = (e) => { 
          e.preventDefault();
          e.stopPropagation();
          active = -1; 
          handles[idx].setAttribute('r', 12);
          handles[idx].setAttribute('opacity', 0.5);
          handles[idx].setAttribute('stroke-width', 2);
          // æ‹–æ‹½ç»“æŸæ—¶æ£€æŸ¥é€šå…³æ¡ä»¶ï¼Œå»¶è¿Ÿæ‰§è¡Œé¿å…çŠ¶æ€å†²çª
          setTimeout(() => {
            const angs = boundsToAngles(bounds);
            if (!isTransitioning && checkPieGoal(lv.goal, angs)) {
              nextLevel();
            }
          }, 50);
        };
        const moveHandler = (e) => {
          if(active !== idx) return;
          e.preventDefault();
          e.stopPropagation();
          const pt = localPoint(svg, e); 
          const x = pt.x - 330, y = pt.y - 380;
          let a = Math.atan2(y, x); 
          if(a < 0) a += TWO;
          clampAround(idx, a);
          update();
          const angs = boundsToAngles(bounds);
          checkPieGoal(lv.goal, angs);
        };
        
        // æ”¯æŒé¼ æ ‡äº‹ä»¶
        touchArea.addEventListener('mousedown', startHandler);
        touchArea.addEventListener('mouseup', endHandler);
        touchArea.addEventListener('mouseleave', endHandler);
        touchArea.addEventListener('mousemove', moveHandler);
        
        // æ”¯æŒæŒ‡é’ˆäº‹ä»¶
        touchArea.addEventListener('pointerdown', startHandler);
        touchArea.addEventListener('pointerup', endHandler);
        touchArea.addEventListener('pointercancel', endHandler);
        touchArea.addEventListener('pointermove', moveHandler);
        
        // æ”¯æŒè§¦æ‘¸äº‹ä»¶
        touchArea.addEventListener('touchstart', startHandler, { passive: false });
        touchArea.addEventListener('touchend', endHandler);
        touchArea.addEventListener('touchcancel', endHandler);
        touchArea.addEventListener('touchmove', moveHandler, { passive: false });
      });

      update();
    }

    function checkPieGoal(goal, angles) {
      if (!goal) return false;
      const fracs = [];
      for (let i=0;i<angles.length-1;i++) fracs.push((angles[i+1]-angles[i])/(2*Math.PI));
      switch(goal.kind) {
        case 'pieIndexAtLeast': {
          return fracs[goal.index] >= goal.fraction;
        }
        case 'pieSumAtLeast': {
          const sum = goal.indices.reduce((s,i)=>s+fracs[i],0);
          return sum >= goal.fraction;
        }
        case 'pieLargest': {
          const idx = goal.index;
          return fracs.every((f,i)=> i===idx || fracs[idx] > f + 0.02);
        }
      }
      return false;
    }

    // ========== å°å·¥å…· ==========
    function create(parent, name, attrs) {
      const el = document.createElementNS('http://www.w3.org/2000/svg', name);
      if (attrs) Object.keys(attrs).forEach(k => el.setAttribute(k, attrs[k]));
      parent.appendChild(el);
      return el;
    }

    function localPoint(svg, evt) {
      // è·å–äº‹ä»¶åæ ‡
      let clientX, clientY;
      if (evt.touches && evt.touches.length > 0) {
        clientX = evt.touches[0].clientX;
        clientY = evt.touches[0].clientY;
      } else if (evt.changedTouches && evt.changedTouches.length > 0) {
        clientX = evt.changedTouches[0].clientX;
        clientY = evt.changedTouches[0].clientY;
      } else {
        clientX = evt.clientX;
        clientY = evt.clientY;
      }
      
      // è·å–SVGå…ƒç´ çš„ä½ç½®å’Œå°ºå¯¸
      const svgRect = svg.getBoundingClientRect();
      
      // è®¡ç®—ç›¸å¯¹äºSVGçš„åæ ‡
      const x = clientX - svgRect.left;
      const y = clientY - svgRect.top;
      
      // è€ƒè™‘SVGçš„viewBoxç¼©æ”¾
      const viewBox = svg.viewBox.baseVal;
      const scaleX = viewBox.width / svgRect.width;
      const scaleY = viewBox.height / svgRect.height;
      
      // è½¬æ¢ä¸ºSVGåæ ‡ç³»
      const svgX = x * scaleX + viewBox.x;
      const svgY = y * scaleY + viewBox.y;
      
      return { x: svgX, y: svgY };
    }

    function successFlash(svg) {
      // å¢å¼ºçš„æˆåŠŸåŠ¨æ•ˆ
      const overlay = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      overlay.setAttribute('x', '0');
      overlay.setAttribute('y', '0');
      overlay.setAttribute('width', '660');
      overlay.setAttribute('height', '900');
      overlay.setAttribute('fill', '#34d399');
      overlay.setAttribute('opacity', '0');
      overlay.style.animation = 'successFlash 0.6s ease-out';
      
      const style = document.createElement('style');
      style.textContent = `
        @keyframes successFlash {
          0% { opacity: 0; transform: scale(0.8); }
          50% { opacity: 0.3; transform: scale(1.1); }
          100% { opacity: 0; transform: scale(1); }
        }
      `;
      document.head.appendChild(style);
      
      svg.appendChild(overlay);
      setTimeout(() => {
        if (overlay.parentNode) overlay.parentNode.removeChild(overlay);
        if (style.parentNode) style.parentNode.removeChild(style);
      }, 600);
    }

    // å¯åŠ¨ï¼šæ˜¾ç¤ºå¼€å§‹ç•Œé¢
    (function init(){
      const best = parseInt(localStorage.getItem('bestScore')||'0',10);
      if (els.bestInfo) els.bestInfo.textContent = best ? `å†å²æœ€ä½³ï¼š${best} é¡µ` : '';
    })();
  </script>
</body>
</html>


