<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
  <title>吹牛PPT大师 - Demo</title>
  <style>
    :root {
      --game-w: 720px;
      --game-h: 1280px;
      --bg: radial-gradient(1200px 800px at 20% 0%, #0f172a 0%, #0b1324 40%, #0b0c10 100%);
      --panel: #ffffff;
      --brand: #ff4d6d;
      --accent: #5dd39e;
      --text: #1f2937;
      --bg-h: 430px; /* 底部背景图高度（可按需调整） */
    }
    html, body {
      height: 100%;
      margin: 0;
      background: var(--bg);
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, 'Noto Sans', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', sans-serif;
      color: #111;
      -webkit-tap-highlight-color: transparent;
      overscroll-behavior: none; /* 阻止下拉刷新/回弹 */
    }
    /* 禁止页面元素被选中 */
    * {
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
    }
    #viewport {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--bg);
      overflow: hidden;
      overscroll-behavior: none;
      touch-action: none; /* 避免浏览器手势干扰 */
    }
    #game {
      width: var(--game-w);
      height: var(--game-h);
      background: linear-gradient(180deg, #f8fafc 0%, #eef2f7 100%);
      border-radius: 18px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.35);
      position: absolute;
      left: 50%;
      top: 50%;
      transform-origin: center center;
    }
    /* 顶部 HUD：进度条 */
    .hud { position: absolute; top: 0; left: 0; right: 0; height: 120px; display: flex; align-items: center; justify-content: center; }
    .progress { position: relative; width: 680px; height: 28px; background: rgba(255,255,255,0.2); border-radius: 14px; overflow: hidden; box-shadow: inset 0 2px 8px rgba(0,0,0,0.2), 0 4px 12px rgba(0,0,0,0.1); backdrop-filter: blur(8px); border: 1px solid rgba(255,255,255,0.3); }
    .progress .bar { position: absolute; left: 0; top: 0; bottom: 0; width: 100%; background: linear-gradient(90deg, #ff4757 0%, #ff6b7a 25%, #ff8a9b 50%, #ff6b7a 75%, #ff4757 100%); background-size: 200% 100%; animation: pulseBar 2s ease-in-out infinite; transition: width .2s ease-out; }
    @keyframes pulseBar {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }
    .progress .text { position: absolute; inset: 0; display: flex; align-items: center; justify-content: center; font-weight: 900; color: #fff; text-shadow: 0 2px 4px rgba(0,0,0,0.8); letter-spacing: 2px; font-size: 16px; }
    .progress.danger .bar { background: linear-gradient(90deg, #ff3838 0%, #ff4757 50%, #ff3838 100%); animation: dangerPulse 0.8s ease-in-out infinite; }
    @keyframes dangerPulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.7; }
    }
    .bg-wrap { position: absolute; left: 40px; right: 40px; bottom: 36px; height: var(--bg-h); z-index: 1; }
    .bg-img { position: absolute; inset: 0; width: 100%; height: 100%; object-fit: contain; border-radius: 16px; box-shadow: 0 8px 24px rgba(0,0,0,0.18); background:#e5e7eb; }
    .boss-speech { position: absolute; left: 16px; right: 16px; top: 12px; background: #fff; border-radius: 16px; box-shadow: 0 8px 24px rgba(0,0,0,0.15); padding: 20px 24px; min-height: 80px; font-size: 20px; line-height: 1.4; display: flex; align-items: center; border-left: 8px solid var(--brand); z-index: 2; transform: translateY(0) scale(1); opacity: 1; transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); }
    .boss-speech.slide-out { transform: translateY(-20px) scale(0.95); opacity: 0; }
    .boss-speech.slide-in { transform: translateY(0) scale(1); opacity: 1; transition-delay: 0.2s; }
    /* PPT 画布 */
    .slide {
      position: absolute;
      left: 40px; right: 40px; bottom: calc(var(--bg-h) + 64px); top: 120px;
      background: var(--panel);
      border-radius: 16px;
      box-shadow: inset 0 0 0 1px rgba(0,0,0,0.06), 0 8px 24px rgba(0,0,0,0.12);
      display: grid;
      grid-template-rows: auto 1fr;
      row-gap: 6px;
    }
    .chart-title { padding: 30px 20px 4px 20px; text-align: center; }
    .chart-title .t-main { font-weight: 900; color: var(--text); font-size: 22px; letter-spacing: .5px; }
    .chart-area { position: relative; display: flex; align-items: center; justify-content: center; padding: 0 12px 30px 12px; overflow: hidden; }
    #chart { width: 100%; height: 92%; }
    .page-counter { position: absolute; left: 0; right: 0; bottom: 38px; text-align: center; font-size: 18px; font-weight: 900; color: #111827; }
    .hint { position: absolute; bottom: 8px; left: 12px; right: 12px; text-align: center; font-size: 14px; color: #6b7280; }
    .overlay { position: absolute; inset: 0; display: none; align-items: center; justify-content: center; background: rgba(3,7,18,0.55); color: #fff; flex-direction: column; gap: 24px; border-radius: 18px; z-index: 20; backdrop-filter: blur(6px); }
    .overlay.show { display: flex; }
    .panel { width: 92%; max-width: 680px; background: rgba(255,255,255,0.95); border: 1px solid rgba(255,255,255,0.3); box-shadow: 0 32px 80px rgba(0,0,0,0.4); border-radius: 24px; padding: 48px 40px; text-align: center; transform: scale(0.9); opacity: 0; animation: popIn 0.4s cubic-bezier(0.34, 1.56, 0.64, 1) forwards; }
    @keyframes popIn {
      to { transform: scale(1); opacity: 1; }
    }
    .panel h1 { margin: 0 0 20px 0; font-size: 48px; font-weight: 900; letter-spacing: -1px; color: #1f2937; line-height: 1.1; }
    .panel p { margin: 16px 0; color: #4b5563; font-size: 24px; line-height: 1.6; font-weight: 500; }
    .panel ul { display: inline-block; text-align: left; margin: 24px auto 32px auto; line-height: 1.8; font-size: 20px; color: #374151; }
    .panel li { margin: 8px 0; }
    .btn { background: linear-gradient(135deg, #ff4d6d, #f87171); color: #fff; border: none; border-radius: 16px; padding: 18px 32px; font-size: 20px; font-weight: 800; cursor: pointer; box-shadow: 0 12px 28px rgba(244,63,94,0.4); transition: all 0.3s ease; transform: translateY(0); }
    .btn:hover { transform: translateY(-2px); box-shadow: 0 16px 36px rgba(244,63,94,0.5); }
    .btn:active { transform: translateY(0); box-shadow: 0 8px 20px rgba(244,63,94,0.3); }
    .btn.secondary { background: #0ea5e9; box-shadow: 0 10px 24px rgba(14,165,233,0.35); }
    .btn.ghost { background: transparent; border: 1px solid rgba(255,255,255,0.5); color: #fff; }
    .legend { font-size: 14px; fill: #4b5563; }
    .label { font-size: 16px; fill: #111827; font-weight: 700; }
    .value { font-size: 14px; fill: #6b7280; }
    .draggable { cursor: grab; touch-action: manipulation; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; pointer-events: auto; }
    .bar-visual { pointer-events: none; }
    .node-visual { pointer-events: none; }
    .pie-handle { pointer-events: none; }
    
    /* 触摸反馈样式 */
    .draggable:active {
      cursor: grabbing;
    }
    
    /* 触摸区域高亮 */
    .draggable:hover {
      opacity: 0.8;
    }
    
    /* 触摸增强样式 */
    .touch-highlight {
      transition: all 0.2s ease;
    }
    
    .touch-highlight:active {
      transform: scale(1.1);
    }

    /* 阻止 iOS/安卓下拉刷新：在根节点捕获 touchmove 并禁止默认 */
    
    /* 增强触摸兼容性 */
    svg * {
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      pointer-events: auto;
    }
    
    .draggable {
      cursor: grab;
      touch-action: manipulation;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      -moz-user-select: none;
      -ms-user-select: none;
      user-select: none;
      pointer-events: auto;
    }
    
    .draggable:active {
      cursor: grabbing;
    }
    
    .draggable circle,
    .draggable rect {
      pointer-events: auto;
    }
  </style>
</head>
<body>
  <div id="viewport">
    <div id="game">
      <div class="hud">
        <div class="progress"><div class="bar" id="timebar"></div><div class="text" id="timetext">60s</div></div>
      </div>
      <div class="slide">
        <div class="chart-title">
          <div class="t-main" id="title">公司概况</div>
        </div>
        <div class="chart-area">
          <svg id="chart" viewBox="0 0 660 650" preserveAspectRatio="xMidYMid meet"></svg>
          <div class="hint" id="hint">拖拽图形改变“视觉效果”，数值不会变</div>
          <div class="page-counter" id="page">已完成 0 页</div>
        </div>
      </div>
      <div class="bg-wrap">
        <img id="img_bg" class="bg-img" alt="bg" src="img_bg.png" />
        <div class="boss-speech" id="boss">“让左边那个柱子看起来比右边高很多。”</div>
      </div>

      <div class="overlay" id="gameover">
        <div class="panel">
          <h1>时间到！</h1>
          <p id="final">-</p>
          <div style="display:flex;gap:12px;flex-wrap:wrap;justify-content:center;">
            <button class="btn" id="restart">再来一局</button>
            <button class="btn ghost" id="backHome">返回标题</button>
          </div>
        </div>
      </div>

      <div class="overlay show" id="startscreen">
        <div class="panel">
          <h1>吹牛PPT大师</h1>
          <p>60 秒内尽可能多地完成老板的“视觉优化”任务。</p>
          <ul>
            <li>柱状图：拖拽柱顶改变高度</li>
            <li>折线图：拖拽节点改变形状</li>
            <li>饼图：拖拽分割线改变占比</li>
          </ul>
          <div style="display:flex;gap:12px;flex-wrap:wrap;justify-content:center;">
            <button class="btn" id="startBtn">开始吹牛</button>
          </div>
          <p id="bestInfo" style="margin-top:12px;font-size:16px;opacity:.9;"></p>
        </div>
      </div>
    </div>
  </div>

  <script>
    // 适配：固定 720x1280，按比例缩放，完整显示（contain，不裁剪）
    function fit() {
      const game = document.getElementById('game');
      const vw = window.innerWidth, vh = window.innerHeight;
      const scale = Math.min(vw / 720, vh / 1280); // contain：全部内容可见，不裁剪
      game.style.transform = `translate(-50%, -50%) scale(${scale})`;
    }
    window.addEventListener('resize', fit);
    fit();

    // 移动端：阻止下拉刷新、回弹，但允许SVG内部交互
    document.addEventListener('touchmove', (e) => {
      // 如果手势发生在游戏容器内，但不包括可拖拽元素，则阻止默认滚动
      const game = document.getElementById('game');
      const target = e.target;
      if (game && game.contains(target) && !target.classList.contains('draggable')) {
        e.preventDefault();
      }
    }, { passive: false });
    
    // 修复iOS Safari的触摸问题
    document.addEventListener('touchstart', (e) => {
      // 允许SVG元素接收触摸事件
      const target = e.target;
      if (target.closest('svg')) {
        // 允许事件继续传播到SVG内部
        return;
      }
    }, { passive: false });

    // 工具
    const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
    const rad = (deg) => deg * Math.PI / 180;
    const deg = (radVal) => radVal * 180 / Math.PI;
    
    // 动效工具
    function animateBossSpeech(text) {
      const boss = document.getElementById('boss');
      boss.classList.add('slide-out');
      setTimeout(() => {
        boss.textContent = '“' + text + '”';
        boss.classList.remove('slide-out');
        boss.classList.add('slide-in');
        setTimeout(() => boss.classList.remove('slide-in'), 300);
      }, 300);
    }
    
    // 增强倒计时进度条动效
    function updateProgressBar(timeLeft) {
      const progress = document.querySelector('.progress');
      const bar = document.querySelector('.progress .bar');
      const percentage = (timeLeft / 60) * 100;
      
      // 移除所有状态类
      progress.classList.remove('danger');
      
      if (timeLeft <= 10) {
        progress.classList.add('danger');
      }
      
      bar.style.width = `${Math.max(0, percentage)}%`;
    }

    // 关卡定义
    const LEVELS = [
      {
        type: 'bar',
        title: '模型对比',
        boss: '兄弟们，这新模型简直吊打全场，跟开挂似的！',
        hint: '',
        bars: [
          { label: 'CPT-5', value: 40, color: '#ff69b4' },
          { label: 'OpenAL o3', value: 65, color: '#a7f3d0' },
          { label: 'CPT-4o', value: 35, color: '#bfdbfe' },
        ],
        goal: { kind: 'barLargest', index: 0 }
      },
      // 扩展关卡开始
      { type:'bar', title:'活跃度环比', boss:'社区活跃度火得不行！', hint:'', bars:[
        {label:'一月', value: 30, color:'#f9a8d4'},
        {label:'二月', value: 25, color:'#86efac'},
        {label:'三月', value: 35, color:'#93c5fd'},
      ], goal:{ kind:'barIncreasing', index:1 } },

      { type:'line', title:'留存趋势', boss:'产品粘性变态，用户跟粘了502似的！', hint:'', points:[35,33,29,25], labels:['W1','W2','W3','W4'], goal:{ kind:'lineEndAboveStart', margin: 10 } },

      { type:'pie', title:'终端分布', boss:'移动端杀疯了，数据爆炸！', hint:'', slices:[
        {label:'移动', value: 20, color:'#34d399'},
        {label:'PC', value: 60, color:'#60a5fa'},
        {label:'平板', value: 20, color:'#fde68a'},
      ], goal:{ kind:'pieIndexAtLeast', index:0, fraction: 0.5 } },

      { type:'bar', title:'渠道转化', boss:'渠道转化离谱，头部直接起飞！', hint:'', bars:[
        {label:'广告', value: 25, color:'#f472b6'},
        {label:'自然', value: 20, color:'#a7f3d0'},
        {label:'内容', value: 15, color:'#fca5a5'},
        {label:'联运', value: 30, color:'#c4b5fd'},
      ], goal:{ kind:'barLargest', index:1 } },

      { type:'line', title:'性能基准(帧率)', boss:'帧率稳得一批！', hint:'', points:[50,55,52,48], labels:['v1','v2','v3','v4'], goal:{ kind:'lineEndAboveStart', margin: 6 } },

      { type:'pie', title:'地区营收', boss:'海外营收开挂，全球都在爆！', hint:'', slices:[
        {label:'北美', value: 25, color:'#93c5fd'},
        {label:'欧洲', value: 35, color:'#c4b5fd'},
        {label:'亚太', value: 40, color:'#86efac'},
      ], goal:{ kind:'pieLargest', index:2 } },

      { type:'bar', title:'研发投入', boss:'研发投入土豪，业内横着走！', hint:'', bars:[
        {label:'21', value: 110, color:'#34d399'},
        {label:'22', value: 100, color:'#60a5fa'},
        {label:'23', value: 95, color:'#fbbf24'},
        {label:'24', value: 80, color:'#f472b6'},
      ], goal:{ kind:'barIncreasing' } },

      { type:'line', title:'客服响应时长', boss:'客服响应快得飞起，用户都惊了！', hint:'', points:[30,28,25,22], labels:['Q1','Q2','Q3','Q4'], goal:{ kind:'lineEndBelowStart', margin: 8 } },

      { type:'pie', title:'功能使用占比', boss:'核心功能使用率逆天，用户爱不释手！', hint:'', slices:[
        {label:'核心A', value: 15, color:'#34d399'},
        {label:'核心B', value: 20, color:'#60a5fa'},
        {label:'长尾', value: 65, color:'#e5e7eb'},
      ], goal:{ kind:'pieIndexAtLeast', index:0, fraction:0.45 } },

      { type:'line', title:'下载时长(秒)', boss:'下载光速，用户都惊呆了！', hint:'', points:[20,18,16,12], labels:['v1','v2','v3','v4'], goal:{ kind:'lineEndBelowStart', margin: 6 } },

      { type:'pie', title:'投诉类型占比', boss:'问题分类精准打击，优化效率爆表！', hint:'', slices:[
        {label:'性能', value: 35, color:'#fca5a5'},
        {label:'体验', value: 30, color:'#fbbf24'},
        {label:'其他', value: 35, color:'#e5e7eb'},
      ], goal:{ kind:'pieLargest', index:0 } },

      { type:'bar', title:'活跃地理热度', boss:'城市渗透病毒式传播，火遍全国！', hint:'', bars:[
        {label:'一线', value: 70, color:'#60a5fa'},
        {label:'二线', value: 60, color:'#34d399'},
        {label:'三线', value: 40, color:'#fbbf24'},
      ], goal:{ kind:'barIncreasing' } },

      { type:'line', title:'错误率(%)', boss:'稳定性变态，错误率都快归零了！', hint:'', points:[2.5,2.3,2.2,1.2], labels:['Q1','Q2','Q3','Q4'], goal:{ kind:'lineEndBelowStart', margin: 0.8 } },

      { type:'pie', title:'人群年龄分布', boss:'年轻用户蜂拥而至，品牌逆龄生长！', hint:'', slices:[
        {label:'18-24', value: 22, color:'#93c5fd'},
        {label:'25-34', value: 48, color:'#60a5fa'},
        {label:'35+', value: 30, color:'#c4b5fd'},
      ], goal:{ kind:'pieLargest', index:1 } },

      { type:'bar', title:'客服满意度', boss:'客服满意度爆表，五星刷到手软！', hint:'', bars:[
        {label:'差评', value: 5, color:'#fca5a5'},
        {label:'一般', value: 15, color:'#fbbf24'},
        {label:'满意', value: 35, color:'#86efac'},
        {label:'很满意', value: 45, color:'#34d399'},
      ], goal:{ kind:'barLargest', index:3 } },

      { type:'line', title:'活跃时段', boss:'黄金时段活跃开挂，内容曝光炸屏！', hint:'', points:[20,30,25,35], labels:['上午','下午','傍晚','夜间'], goal:{ kind:'lineEndAboveStart', margin: 8 } },

      { type:'pie', title:'订阅套餐占比', boss:'高阶套餐卖疯了，ARPU直接起飞！', hint:'', slices:[
        {label:'基础', value: 50, color:'#e5e7eb'},
        {label:'进阶', value: 30, color:'#60a5fa'},
        {label:'旗舰', value: 20, color:'#34d399'},
      ], goal:{ kind:'pieIndexAtLeast', index:2, fraction:0.35 } },

      { type:'bar', title:'站点可用率(%)', boss:'在线率变态，全年不掉线！', hint:'', bars:[
        {label:'Q1', value: 99.0, color:'#86efac'},
        {label:'Q2', value: 99.3, color:'#93c5fd'},
        {label:'Q3', value: 99.6, color:'#fbbf24'},
        {label:'Q4', value: 99.1, color:'#f472b6'},
      ], goal:{ kind:'barIncreasing' } },

      { type:'line', title:'付费转化(%)', boss:'转化率火箭升空，变现效率爆表！', hint:'', points:[2.1,2.2,2.0,2.8], labels:['M1','M2','M3','M4'], goal:{ kind:'lineEndAboveStart', margin: 0.5 } },

      { type:'pie', title:'内容题材热度', boss:'热点自带流量，优质内容被疯抢！', hint:'', slices:[
        {label:'科技', value: 28, color:'#60a5fa'},
        {label:'生活', value: 40, color:'#34d399'},
        {label:'娱乐', value: 32, color:'#fbbf24'},
      ], goal:{ kind:'pieLargest', index:1 } },

      { type:'line', title:'学习曲线', boss:'上手难度幼儿园级别，用户秒变老司机！', hint:'', points:[80,70,60,40], labels:['D1','D2','D3','D4'], goal:{ kind:'lineEndBelowStart', margin: 20 } },

      { type:'bar', title:'线索到签约', boss:'销售简直印钞机，转化率爆表！', hint:'', bars:[
        {label:'线索', value: 300, color:'#60a5fa'},
        {label:'商机', value: 120, color:'#fbbf24'},
        {label:'签约', value: 40, color:'#34d399'},
      ], goal:{ kind:'barLastMultipleFirst', multiple: 0.5 } },
      {
        type: 'line',
        title: '月活趋势',
        boss: '月活一路狂飙不带停的！',
        hint: '',
        points: [120, 100, 80, 75],
        labels: ['Q1','Q2','Q3','Q4'],
        goal: { kind: 'lineEndAboveStart', margin: 40 }
      },
      {
        type: 'pie',
        title: '市场份额',
        boss: '市场这地位无敌，吊打友商十条街！',
        hint: '',
        slices: [
          { label: '本公司', value: 20, color: '#60a5fa' },
          { label: '竞品A', value: 60, color: '#fca5a5' },
          { label: '竞品B', value: 20, color: '#fde68a' }
        ],
        goal: { kind: 'pieIndexAtLeast', index: 0, fraction: 0.6 }
      },
      {
        type: 'bar',
        title: '季度利润（万元）',
        boss: '利润爆表，数钱数到手抽筋！',
        hint: '',
        bars: [
          { label: 'Q1', value: -30, color: '#c4b5fd' },
          { label: 'Q2', value: -35, color: '#93c5fd' },
          { label: 'Q3', value: -25, color: '#86efac' },
          { label: 'Q4', value: -15, color: '#fca5a5' },
        ],
        goal: { kind: 'barIncreasing' }
      },
      {
        type: 'pie',
        title: '满意度调查',
        boss: '口碑炸裂，用户都成自来水了！',
        hint: '',
        slices: [
          { label: '很满意', value: 15, color: '#34d399' },
          { label: '满意', value: 30, color: '#6ee7b7' },
          { label: '其他', value: 55, color: '#e5e7eb' },
        ],
        goal: { kind: 'pieSumAtLeast', indices: [0,1], fraction: 0.9 }
      },
      {
        type: 'pie',
        title: '转化来源占比',
        boss: '广告渠道简直是金矿，流量哗哗的！',
        hint: '',
        slices: [
          { label: '广告', value: 15, color: '#f472b6' },
          { label: '自然', value: 65, color: '#93c5fd' },
          { label: '推荐', value: 20, color: '#fde68a' },
        ],
        goal: { kind: 'pieLargest', index: 0 }
      },
    ];

    // 全局状态
    let current = 0;
    let score = 0;
    let levelCleared = false; // 防止同一关卡多次计数
    let timeLeft = 60;
    let timerId = null;
    let isTransitioning = false; // 防止快速拖拽导致重复计数

    const els = {
      timebar: document.getElementById('timebar'),
      timetext: document.getElementById('timetext'),
      page: document.getElementById('page'),
      boss: document.getElementById('boss'),
      title: document.getElementById('title'),
      subtitle1: document.getElementById('subtitle1'),
      subtitle2: document.getElementById('subtitle2'),
      chart: document.getElementById('chart'),
      hint: document.getElementById('hint'),
      over: document.getElementById('gameover'),
      final: document.getElementById('final'),
      restart: document.getElementById('restart'),
      start: document.getElementById('startscreen'),
      startBtn: document.getElementById('startBtn'),
      backHome: document.getElementById('backHome'),
      bestInfo: document.getElementById('bestInfo'),
    };

    function start() {
      score = 0; current = 0; timeLeft = 60;
      els.page.textContent = `已完成 ${score} 页`;
      els.timetext.textContent = `${timeLeft}s`;
      updateProgressBar(timeLeft);
      els.over.classList.remove('show');
      els.start.classList.remove('show');
      renderLevel();
      if (timerId) clearInterval(timerId);
      timerId = setInterval(() => {
        timeLeft -= 1;
        els.timetext.textContent = `${timeLeft}s`;
        updateProgressBar(timeLeft);
        if (timeLeft <= 0) {
          clearInterval(timerId);
          timerId = null;
          gameOver();
        }
      }, 1000);
    }

    // 段位系统
    const TITLES = [
      { min: 0, max: 5, name: '职场小白', icon: '🌱', color: '#9ca3af', desc: '初入职场，还需努力！' },
      { min: 6, max: 10, name: '数据学徒', icon: '📊', color: '#60a5fa', desc: '开始掌握数据魔法！' },
      { min: 11, max: 15, name: '图表能手', icon: '📈', color: '#34d399', desc: '图表操作行云流水！' },
      { min: 16, max: 20, name: '视觉大师', icon: '🎨', color: '#fbbf24', desc: '视觉呈现出神入化！' },
      { min: 21, max: 25, name: '吹牛专家', icon: '💼', color: '#f472b6', desc: '老板最爱的PPT大师！' },
      { min: 26, max: 30, name: '数据影帝', icon: '👑', color: '#8b5cf6', desc: '登峰造极，数据界的奥斯卡！' }
    ];
    
    function getTitle(score) {
      return TITLES.find(t => score >= t.min && score <= t.max) || TITLES[0];
    }
    
    function gameOver() {
      const best = Math.max(score, parseInt(localStorage.getItem('bestScore')||'0',10));
      localStorage.setItem('bestScore', best.toString());
      
      const currentTitle = getTitle(score);
      const bestTitle = getTitle(best);
      
      // 构建成就展示HTML
      const achievementHTML = `
        <div style="text-align: center; margin: 24px 0;">
          <div style="font-size: 64px; margin-bottom: 16px;">${currentTitle.icon}</div>
          <div style="font-size: 28px; font-weight: 900; color: ${currentTitle.color}; margin-bottom: 8px;">
            ${currentTitle.name}
          </div>
          <div style="font-size: 18px; color: #6b7280; margin-bottom: 24px;">
            ${currentTitle.desc}
          </div>
          <div style="display: flex; justify-content: space-around; margin: 32px 0; text-align: center;">
            <div>
              <div style="font-size: 36px; font-weight: 900; color: ${currentTitle.color};">${score}</div>
              <div style="font-size: 16px; color: #6b7280;">本次成绩</div>
            </div>
            <div>
              <div style="font-size: 36px; font-weight: 900; color: ${bestTitle.color};">${best}</div>
              <div style="font-size: 16px; color: #6b7280;">历史最佳</div>
            </div>
          </div>
          ${score === best && score > 0 ? `
            <div style="background: linear-gradient(135deg, #fbbf24, #f59e0b); color: white; padding: 12px 24px; border-radius: 20px; font-weight: 900; margin: 16px 0; display: inline-block;">
              🎉 创造新纪录！
            </div>
          ` : ''}
        </div>
      `;
      
      els.final.innerHTML = achievementHTML;
      els.over.classList.add('show');
    }
    els.restart.addEventListener('click', start);
    els.startBtn && els.startBtn.addEventListener('click', start);
    els.backHome && els.backHome.addEventListener('click', () => {
      els.over.classList.remove('show');
      els.start.classList.add('show');
      const best = parseInt(localStorage.getItem('bestScore')||'0',10);
      if (els.bestInfo) els.bestInfo.textContent = best ? `历史最佳：${best} 页` : '';
    });

    function nextLevel() {
      if (isTransitioning) return; // 防止重复计数
      isTransitioning = true;
      
      score += 1;
      els.page.textContent = `已完成 ${score} 页`;
      current = (current + 1) % LEVELS.length;
      
      // 添加完成动效
      const svg = els.chart;
      successFlash(svg);
      
      setTimeout(() => {
        renderLevel();
        isTransitioning = false; // 重置状态
      }, 400);
    }

    function renderLevel() {
      const lv = LEVELS[current];
      const svg = els.chart;
      svg.innerHTML = '';
      
      // 使用动画更新老板对话
      animateBossSpeech(lv.boss);
      
      // 重置状态
      els.title.textContent = lv.title;
      if (els.subtitle1) {
        els.subtitle1.textContent = lv.sub1 || '副标题一：真实数据仅作示意，请通过拖拽调整图形外观。';
      }
      if (els.subtitle2) {
        els.subtitle2.textContent = lv.sub2 || '副标题二：完成老板目标即可进入下一页。';
      }
      // 通用操作提示：依据图表类型
      const hints = { bar: '提示：图表可交互', line: '提示：图表可交互', pie: '提示：图表可交互' };
      els.hint.textContent = lv.hint || hints[lv.type] || '';
      
      // 为每个图表创建独立作用域，避免状态污染
      if (lv.type === 'bar') renderBar(lv, svg);
      else if (lv.type === 'line') renderLine(lv, svg);
      else if (lv.type === 'pie') renderPie(lv, svg);
    }

    // ========== 柱状图 ==========
    function renderBar(lv, svg) {
      const W = 620, H = 560, offsetX = 20, offsetY = 100;
      // 坐标系背景
      const g = create(svg, 'g', { transform: `translate(20,60)` });
      create(g, 'rect', { x: 0, y: 0, width: W, height: H, fill: '#f8fafc', rx: 12, ry: 12, stroke: '#e5e7eb' });

      const n = lv.bars.length;
      const gap = 24, barW = (W - gap * (n + 1)) / n;
      const baseY = H - 40; // 留出底部
      const maxVisual = H - 80;

      // 以真实数值严格成比例显示：按绝对值相对最大值映射
      const values = lv.bars.map(b => b.value);
      const maxAbs = Math.max(1e-6, ...values.map(v => Math.abs(v)));
      const visualHeights = lv.bars.map(b => Math.abs(b.value) / maxAbs * maxVisual);

      // 画刻度
      for (let i = 0; i <= 4; i++) {
        const y = 20 + i * ((H-60)/4);
        create(g, 'line', { x1: 0, y1: y, x2: W, y2: y, stroke: '#e5e7eb' });
      }

      // 交互
      let dragging = null;

      lv.bars.forEach((b, i) => {
        const x = gap + i * (barW + gap);
        const barGroup = create(g, 'g', {});
        // 创建更大的触摸区域
        const touchArea = create(barGroup, 'rect', {
          x: x - 10,
          y: 0,
          width: barW + 20,
          height: H,
          fill: 'transparent',
          class: 'draggable'
        });
        const rect = create(barGroup, 'rect', {
          x,
          y: baseY - visualHeights[i],
          width: barW,
          height: visualHeights[i],
          fill: b.color,
          rx: 8,
          class: 'bar-visual'
        });
        const label = create(barGroup, 'text', { x: x + barW/2, y: baseY + 22, 'text-anchor': 'middle', class: 'legend' });
        label.textContent = b.label;
        const value = create(barGroup, 'text', { x: x + barW/2, y: baseY + 40, 'text-anchor': 'middle', class: 'value' });
        value.textContent = `${b.value}`;

        const startHandler = (e) => { 
          e.preventDefault();
          e.stopPropagation();
          dragging = i; 
          if (e.pointerId !== undefined) touchArea.setPointerCapture(e.pointerId);
          rect.style.transform = 'scale(1.05)';
          rect.style.transformOrigin = 'center bottom';
          rect.style.transition = 'transform 0.1s';
        };
        const endHandler = (e) => { 
          e.preventDefault();
          e.stopPropagation();
          dragging = null; 
          rect.style.transform = 'scale(1)';
          // 拖拽结束时检查通关条件，延迟执行避免状态冲突
          setTimeout(() => {
            if (!isTransitioning && checkBarGoal(lv.goal, visualHeights)) {
              nextLevel();
            }
          }, 50);
        };
        const moveHandler = (e) => {
          if (dragging !== i) return;
          e.preventDefault();
          e.stopPropagation();
          const pt = localPoint(svg, e);
          const localY = pt.y - 60; // 减去 translate
          const h = clamp(baseY - localY, 20, maxVisual);
          visualHeights[i] = h;
          rect.setAttribute('y', baseY - h);
          rect.setAttribute('height', h);
          checkBarGoal(lv.goal, visualHeights);
        };
        
        // 支持鼠标事件
        touchArea.addEventListener('mousedown', startHandler);
        touchArea.addEventListener('mouseup', endHandler);
        touchArea.addEventListener('mouseleave', endHandler);
        touchArea.addEventListener('mousemove', moveHandler);
        
        // 支持指针事件
        touchArea.addEventListener('pointerdown', startHandler);
        touchArea.addEventListener('pointerup', endHandler);
        touchArea.addEventListener('pointercancel', endHandler);
        touchArea.addEventListener('pointermove', moveHandler);
        
        // 支持触摸事件
        touchArea.addEventListener('touchstart', startHandler, { passive: false });
        touchArea.addEventListener('touchend', endHandler);
        touchArea.addEventListener('touchcancel', endHandler);
        touchArea.addEventListener('touchmove', moveHandler, { passive: false });
      });
    }

    function checkBarGoal(goal, heights) {
      if (!goal) return false;
      const minGap = 10;
      switch(goal.kind) {
        case 'barLargest': {
          const idx = goal.index;
          return heights.every((h, i) => i === idx || heights[idx] >= h + minGap);
        }
        case 'barIncreasing': {
          for (let i = 0; i < heights.length - 1; i++) {
            if (!(heights[i] + minGap < heights[i+1])) return false;
          }
          return true;
        }
        case 'barLastMultipleFirst': {
          const m = goal.multiple || 2;
          return heights[heights.length - 1] >= heights[0] * m;
        }
      }
      return false;
    }

    // ========== 折线图 ==========
    function renderLine(lv, svg) {
      const W = 620, H = 560, L = 50, T = 60;
      const g = create(svg, 'g', { transform: `translate(20,60)` });
      create(g, 'rect', { x: 0, y: 0, width: W, height: H, fill: '#f8fafc', rx: 12, ry: 12, stroke: '#e5e7eb' });

      const n = lv.points.length;
      const X0 = L, Y0 = H - 40, chartW = W - L - 20, chartH = H - T - 40;
      const stepX = chartW / (n - 1);
      // 初始视觉点位：严格按真实值映射
      const maxVal = Math.max(...lv.points);
      const minVal = Math.min(...lv.points);
      const mapY = v => Y0 - (v - minVal) / Math.max(1, (maxVal - minVal)) * chartH;
      const vPoints = lv.points.map((v,i) => ({ x: X0 + i*stepX, y: mapY(v) }));

      // 网格
      for (let i=0;i<=4;i++) {
        const y = T + i * (chartH/4);
        create(g, 'line', { x1: X0, y1: y, x2: X0 + chartW, y2: y, stroke: '#e5e7eb' });
      }
      create(g, 'line', { x1: X0, y1: T, x2: X0, y2: Y0, stroke: '#d1d5db' });
      create(g, 'line', { x1: X0, y1: Y0, x2: X0 + chartW, y2: Y0, stroke: '#d1d5db' });

      const path = create(g, 'polyline', { fill: 'none', stroke: '#2563eb', 'stroke-width': 3, points: pointsStr(vPoints) });

      // 真实数据标签
      vPoints.forEach((p, i) => {
        const tx = create(g, 'text', { x: p.x, y: Y0 + 22, 'text-anchor': 'middle', class: 'legend' });
        tx.textContent = lv.labels ? lv.labels[i] : `P${i+1}`;
        const val = create(g, 'text', { x: p.x, y: Y0 + 40, 'text-anchor': 'middle', class: 'value' });
        val.textContent = lv.points[i];
      });

      let dragging = -1;
      vPoints.forEach((p, i) => {
        // 创建更大的触摸区域（透明大圆）
        const touchArea = create(g, 'circle', { 
          cx: p.x, 
          cy: p.y, 
          r: 25, // 触摸区域半径
          fill: 'transparent', 
          class: 'draggable' 
        });
        // 创建可见小圆
        const c = create(g, 'circle', { 
          cx: p.x, 
          cy: p.y, 
          r: 8, 
          fill: '#2563eb', 
          stroke: '#fff', 
          'stroke-width': 2,
          class: 'node-visual' 
        });
        
        const startHandler = (e) => { 
          e.preventDefault();
          e.stopPropagation();
          dragging = i; 
          if (e.pointerId !== undefined) touchArea.setPointerCapture(e.pointerId);
          c.setAttribute('r', 12); // 触摸反馈
          c.setAttribute('stroke-width', 3);
        };
        const endHandler = (e) => { 
          e.preventDefault();
          e.stopPropagation();
          dragging = -1; 
          c.setAttribute('r', 8);
          c.setAttribute('stroke-width', 2);
          // 拖拽结束时检查通关条件，延迟执行避免状态冲突
          setTimeout(() => {
            if (!isTransitioning && checkLineGoal(lv.goal, vPoints)) {
              nextLevel();
            }
          }, 50);
        };
        const moveHandler = (e) => {
          if (dragging !== i) return;
          e.preventDefault();
          e.stopPropagation();
          const pt = localPoint(svg, e);
          const local = { x: clamp(pt.x - 20, X0, X0 + chartW), y: clamp(pt.y - 60, T, Y0) };
          p.y = local.y;
          // 同时更新触摸区域和可见圆的位置
          c.setAttribute('cy', p.y);
          touchArea.setAttribute('cy', p.y);
          path.setAttribute('points', pointsStr(vPoints));
          checkLineGoal(lv.goal, vPoints);
        };
        
        // 支持鼠标事件
        touchArea.addEventListener('mousedown', startHandler);
        touchArea.addEventListener('mouseup', endHandler);
        touchArea.addEventListener('mouseleave', endHandler);
        touchArea.addEventListener('mousemove', moveHandler);
        
        // 支持指针事件
        touchArea.addEventListener('pointerdown', startHandler);
        touchArea.addEventListener('pointerup', endHandler);
        touchArea.addEventListener('pointercancel', endHandler);
        touchArea.addEventListener('pointermove', moveHandler);
        
        // 支持触摸事件
        touchArea.addEventListener('touchstart', startHandler, { passive: false });
        touchArea.addEventListener('touchend', endHandler);
        touchArea.addEventListener('touchcancel', endHandler);
        touchArea.addEventListener('touchmove', moveHandler, { passive: false });
      });
    }

    function pointsStr(arr) { return arr.map(p => `${p.x},${p.y}`).join(' '); }
    function checkLineGoal(goal, pts) {
      if (!goal) return false;
      const startY = pts[0].y, endY = pts[pts.length - 1].y;
      switch(goal.kind) {
        case 'lineEndAboveStart': {
          return startY - endY > (goal.margin || 20);
        }
        case 'lineEndBelowStart': {
          return endY - startY > (goal.margin || 20);
        }
        case 'lineEndBelowRatio': {
          // 这里用 Y 轴朝下：越大越低。目标：end <= start * ratio（视觉显著降低）
          // 换成像素差判定：start - end >= (1-ratio) * 200 像素
          const need = 160 * (1 - (goal.ratio || 0.5));
          return startY - endY >= need;
        }
      }
      return false;
    }

    // ========== 饼图 ==========
    function renderPie(lv, svg) {
      const g = create(svg, 'g', { transform: `translate(330,380)` });
      const R = 180;
      const slices = lv.slices;
      // 边界角数组（绝对角度，0..2π），长度为切片数量 n；第 i 段为 [bounds[i], bounds[i+1])，最后一段闭合到 bounds[0]+2π
      const sum = slices.reduce((s,it)=>s+it.value,0);
      let bounds = [0];
      let acc = 0;
      for (let i=0;i<slices.length-1;i++) { acc += (slices[i].value / sum) * Math.PI*2; bounds.push(acc); }
      // DOM：固定节点，拖动时仅更新属性
      create(g, 'circle', { cx:0, cy:0, r:R+20, fill:'#f8fafc', stroke:'#e5e7eb' });
      const paths = slices.map(()=> create(g,'path', { stroke:'#fff', 'stroke-width':2 }));
      const labels = slices.map(()=> create(g,'text', { class:'label' }));
      // 创建更大的触摸区域（透明大圆）
      const touchAreas = bounds.map(()=> create(g,'circle', { r:30, fill:'transparent', class:'draggable' }));
      // 创建可见控制点
      const handles = bounds.map(()=> create(g,'circle', { r:12, fill:'#111827', stroke:'#fff', 'stroke-width':2, opacity:0.5, class:'pie-handle' }));

      const TWO = Math.PI*2;
      const norm = (a)=>{ const t=a%TWO; return t<0?t+TWO:t; };
      const fwd = (a,b)=> (b - a + TWO) % TWO; // 从a沿正向到b的角距离
      const arcD = (a0,a1)=>{
        const end = a0 + fwd(a0, a1);
        const large = (end-a0)>Math.PI?1:0;
        const p0={x:Math.cos(a0)*R,y:Math.sin(a0)*R};
        const p1={x:Math.cos(end)*R,y:Math.sin(end)*R};
        return `M0,0 L${p0.x},${p0.y} A ${R} ${R} 0 ${large} 1 ${p1.x},${p1.y} Z`;
      };

      function boundsToAngles(bnds){
        // 生成 [0, ..., 2π] 形式，供目标判定使用
        const base=bnds[0];
        const arr=[0];
        for(let i=1;i<bnds.length;i++) arr.push(norm(bnds[i]-base));
        arr.push(TWO);
        return arr;
      }

      function update(){
        // 更新扇形与文字
        for(let i=0;i<slices.length;i++){
          const a0=bounds[i];
          const a1=(i===slices.length-1) ? bounds[0] : bounds[i+1];
          paths[i].setAttribute('d', arcD(a0,a1));
          paths[i].setAttribute('fill', slices[i].color);
          const mid = a0 + fwd(a0, a1) / 2; // 使用正向跨度，避免跨圈导致的标签跳动
          const px=Math.cos(mid)* (R+36); const py=Math.sin(mid)*(R+36);
          labels[i].setAttribute('x', px); labels[i].setAttribute('y', py);
          labels[i].setAttribute('text-anchor', px>=0?'start':'end');
          labels[i].textContent=`${slices[i].label} ${slices[i].value}%`;
        }
        // 把手（含缝合处 index=0）
        for(let k=0;k<handles.length;k++){
          const a=bounds[k];
          const x = Math.cos(a)*R;
          const y = Math.sin(a)*R;
          handles[k].setAttribute('cx', x);
          handles[k].setAttribute('cy', y);
          touchAreas[k].setAttribute('cx', x);
          touchAreas[k].setAttribute('cy', y);
        }
      }

      function clampAround(index, aNew){
        const margin=0.1;
        const prevIndex=(index-1+slices.length)%slices.length;
        const nextIndex=(index+1)%slices.length;
        const start = norm(bounds[prevIndex] + margin);
        const end = norm(bounds[nextIndex] - margin);
        // 将 aNew 限制在从 start 到 end 的正向弧段内
        const segLen = fwd(start, end);
        let d = fwd(start, norm(aNew));
        if (d > segLen) d = segLen;
        const a = norm(start + d);
        bounds[index]=a;
      }

      let active=-1;
      touchAreas.forEach((touchArea, idx)=>{
        const startHandler = (e) => { 
          e.preventDefault();
          e.stopPropagation();
          active = idx; 
          if (e.pointerId !== undefined) touchArea.setPointerCapture(e.pointerId);
          handles[idx].setAttribute('r', 18); // 触摸反馈
          handles[idx].setAttribute('opacity', 0.8);
          handles[idx].setAttribute('stroke-width', 3);
        };
        const endHandler = (e) => { 
          e.preventDefault();
          e.stopPropagation();
          active = -1; 
          handles[idx].setAttribute('r', 12);
          handles[idx].setAttribute('opacity', 0.5);
          handles[idx].setAttribute('stroke-width', 2);
          // 拖拽结束时检查通关条件，延迟执行避免状态冲突
          setTimeout(() => {
            const angs = boundsToAngles(bounds);
            if (!isTransitioning && checkPieGoal(lv.goal, angs)) {
              nextLevel();
            }
          }, 50);
        };
        const moveHandler = (e) => {
          if(active !== idx) return;
          e.preventDefault();
          e.stopPropagation();
          const pt = localPoint(svg, e); 
          const x = pt.x - 330, y = pt.y - 380;
          let a = Math.atan2(y, x); 
          if(a < 0) a += TWO;
          clampAround(idx, a);
          update();
          const angs = boundsToAngles(bounds);
          checkPieGoal(lv.goal, angs);
        };
        
        // 支持鼠标事件
        touchArea.addEventListener('mousedown', startHandler);
        touchArea.addEventListener('mouseup', endHandler);
        touchArea.addEventListener('mouseleave', endHandler);
        touchArea.addEventListener('mousemove', moveHandler);
        
        // 支持指针事件
        touchArea.addEventListener('pointerdown', startHandler);
        touchArea.addEventListener('pointerup', endHandler);
        touchArea.addEventListener('pointercancel', endHandler);
        touchArea.addEventListener('pointermove', moveHandler);
        
        // 支持触摸事件
        touchArea.addEventListener('touchstart', startHandler, { passive: false });
        touchArea.addEventListener('touchend', endHandler);
        touchArea.addEventListener('touchcancel', endHandler);
        touchArea.addEventListener('touchmove', moveHandler, { passive: false });
      });

      update();
    }

    function checkPieGoal(goal, angles) {
      if (!goal) return false;
      const fracs = [];
      for (let i=0;i<angles.length-1;i++) fracs.push((angles[i+1]-angles[i])/(2*Math.PI));
      switch(goal.kind) {
        case 'pieIndexAtLeast': {
          return fracs[goal.index] >= goal.fraction;
        }
        case 'pieSumAtLeast': {
          const sum = goal.indices.reduce((s,i)=>s+fracs[i],0);
          return sum >= goal.fraction;
        }
        case 'pieLargest': {
          const idx = goal.index;
          return fracs.every((f,i)=> i===idx || fracs[idx] > f + 0.02);
        }
      }
      return false;
    }

    // ========== 小工具 ==========
    function create(parent, name, attrs) {
      const el = document.createElementNS('http://www.w3.org/2000/svg', name);
      if (attrs) Object.keys(attrs).forEach(k => el.setAttribute(k, attrs[k]));
      parent.appendChild(el);
      return el;
    }

    function localPoint(svg, evt) {
      // 获取事件坐标
      let clientX, clientY;
      if (evt.touches && evt.touches.length > 0) {
        clientX = evt.touches[0].clientX;
        clientY = evt.touches[0].clientY;
      } else if (evt.changedTouches && evt.changedTouches.length > 0) {
        clientX = evt.changedTouches[0].clientX;
        clientY = evt.changedTouches[0].clientY;
      } else {
        clientX = evt.clientX;
        clientY = evt.clientY;
      }
      
      // 获取SVG元素的位置和尺寸
      const svgRect = svg.getBoundingClientRect();
      
      // 计算相对于SVG的坐标
      const x = clientX - svgRect.left;
      const y = clientY - svgRect.top;
      
      // 考虑SVG的viewBox缩放
      const viewBox = svg.viewBox.baseVal;
      const scaleX = viewBox.width / svgRect.width;
      const scaleY = viewBox.height / svgRect.height;
      
      // 转换为SVG坐标系
      const svgX = x * scaleX + viewBox.x;
      const svgY = y * scaleY + viewBox.y;
      
      return { x: svgX, y: svgY };
    }

    function successFlash(svg) {
      // 增强的成功动效
      const overlay = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
      overlay.setAttribute('x', '0');
      overlay.setAttribute('y', '0');
      overlay.setAttribute('width', '660');
      overlay.setAttribute('height', '900');
      overlay.setAttribute('fill', '#34d399');
      overlay.setAttribute('opacity', '0');
      overlay.style.animation = 'successFlash 0.6s ease-out';
      
      const style = document.createElement('style');
      style.textContent = `
        @keyframes successFlash {
          0% { opacity: 0; transform: scale(0.8); }
          50% { opacity: 0.3; transform: scale(1.1); }
          100% { opacity: 0; transform: scale(1); }
        }
      `;
      document.head.appendChild(style);
      
      svg.appendChild(overlay);
      setTimeout(() => {
        if (overlay.parentNode) overlay.parentNode.removeChild(overlay);
        if (style.parentNode) style.parentNode.removeChild(style);
      }, 600);
    }

    // 启动：显示开始界面
    (function init(){
      const best = parseInt(localStorage.getItem('bestScore')||'0',10);
      if (els.bestInfo) els.bestInfo.textContent = best ? `历史最佳：${best} 页` : '';
    })();
  </script>
</body>
</html>


